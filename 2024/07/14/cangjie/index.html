<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>仓颉 | CityFire的技术世界</title><meta name="author" content="CityFire"><meta name="copyright" content="CityFire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="随着万物互联以及智能时代的到来，软件的形态将发生巨大的变化。一方面，移动应用和移动互联网领域仍然强力驱动人机交互、设备协同、智能化、安全性等方向的创新，另一方面人工智能也同样驱动软件朝智能化、端边云协同等方向演进。新技术、新场景下应用软件的开发对编程语言提出了新的诉求和挑战。 仓颉编程语言作为一款面向全场景应用开发的现代编程语言，通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的">
<meta property="og:type" content="article">
<meta property="og:title" content="仓颉">
<meta property="og:url" content="https://cityfire.github.io/2024/07/14/cangjie/index.html">
<meta property="og:site_name" content="CityFire的技术世界">
<meta property="og:description" content="随着万物互联以及智能时代的到来，软件的形态将发生巨大的变化。一方面，移动应用和移动互联网领域仍然强力驱动人机交互、设备协同、智能化、安全性等方向的创新，另一方面人工智能也同样驱动软件朝智能化、端边云协同等方向演进。新技术、新场景下应用软件的开发对编程语言提出了新的诉求和挑战。 仓颉编程语言作为一款面向全场景应用开发的现代编程语言，通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2024-07-14T03:43:59.000Z">
<meta property="article:modified_time" content="2024-07-14T03:43:59.000Z">
<meta property="article:author" content="CityFire">
<meta property="article:tag" content="Objective-C、Swift、C、C++、Java、Cangjie、ArkTS、Go、Python、Dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cityfire.github.io/2024/07/14/cangjie/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '仓颉',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-14 11:43:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="CityFire的技术世界"><span class="site-name">CityFire的技术世界</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">仓颉</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-14T03:43:59.000Z" title="发表于 2024-07-14 11:43:59">2024-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-14T03:43:59.000Z" title="更新于 2024-07-14 11:43:59">2024-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%B8%BF%E8%92%99/">鸿蒙</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="仓颉"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>随着万物互联以及智能时代的到来，软件的形态将发生巨大的变化。一方面，移动应用和移动互联网领域仍然强力驱动人机交互、设备协同、智能化、安全性等方向的创新，另一方面人工智能也同样驱动软件朝智能化、端边云协同等方向演进。新技术、新场景下应用软件的开发对编程语言提出了新的诉求和挑战。</p>
<p>仓颉编程语言作为一款面向全场景应用开发的现代编程语言，通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的IDE工具链支持，为开发者打造友好开发体验和卓越程序性能。其具体特性表现为：</p>
<ul>
<li><p>高效编程：面向应用开发，我们希望语言能够易学易用，降低开发者入门门槛和开发过程中的心智负担，支持各种常见的开发范式和编程模式，让开发者简洁高效地表达各种业务逻辑。仓颉是一门多范式编程语言，支持函数式、命令式和面向对象等多种范式，包括值类型、类和接口、泛型、代数数据类型、模式匹配、以及高阶函数等特性。此外，仓颉还支持类型推断，能够减轻开发者类型标注的负担；通过一系列简明高效的语法，能够减少冗余书写、提升开发效率；语言内置的各种语法糖和宏（macro）的能力，支持开发者基于仓颉快速开发领域专用语言（DSL），构建领域抽象。</p>
</li>
<li><p>安全可靠：作为现代编程语言，仓颉追求编码即安全，通过静态类型系统和自动内存管理，确保程序的类型安全和null safety等内存安全；同时，仓颉还提供各种运行时检查，包括数组下标越界检查、类型转换检查、数值计算溢出检查、以及字符串编码合法性检查等，能够及时发现程序运行中的错误；此外，还通过代码扫描工具、混淆工具以及消毒器，进一步提供跨语言互操作安全和代码资产保护等支持。</p>
</li>
<li><p>轻松并发：并发和异步编程能够有效提高处理器利用率，并在交互式应用中确保程序的响应速度，是应用开发中必不可少的能力。仓颉语言实现了轻量化用户态线程和并发对象库，让高效并发变得轻松。</p>
</li>
</ul>
<p>仓颉语言采用用户态线程模型，每个仓颉线程都是极其轻量级的执行实体，拥有独立的执行上下文但共享内存。对开发者来说，用户态线程的使用和传统的系统线程的使用方式保持一致，没有带来额外负担；而从运行态视角看，线程的管理由运行时完成，不依赖操作系统的线程管理，因此线程的创建、调度和销毁等操作更加高效，且资源占用比系统线程更少。为了避免数据竞争，仓颉语言提供了并发对象库，并发对象的方法是线程安全的，因此在多线程中调用这些方法和串行编程没有区别，应用逻辑的开发者无需额外关心并发管理。对于一些核心库，仓颉还提供了无锁或者细粒度锁的算法实现，能够进一步减少线程的阻塞，提升并发度。</p>
<ul>
<li>卓越性能：仓颉编译器及运行时从全栈对编译进行优化，包括编译器前端基于CHIR（Cangjie HighLevel IR）高层编译优化（比如语义感知的循环优化、语义感知的后端协同优化等），基于后端的编译优化（比如：SLP向量化、Intrinsic优化、InlineCache、过程间指针优化、Barrier优化等），基于运行时的优化（比如轻量锁、分布式标记、并发Tracing优化等），一系列的优化让仓颉充分发挥处理器能力，为应用提供卓越的性能支持。另外仓颉语言对运行时进行原生的轻量化设计，通过对运行时模块化分层设计，定义仓颉公共对象模型和运行时公共基础组件，基于公共对象模型，实现运行时的内存管理、回栈、异常处理、跨语言调用等基础能力，大幅减少多个能力间的冗余对象设计，精简运行时体积。同时通过包的按需加载技术，减少仓颉应用启动的冗余包内存开销，因此对于资源敏感设备，占用资源更少，支持更友好。</li>
</ul>
<p>除此之外，仓颉还支持面向应用开发的一系列工具链，包括语言服务（高亮、联想）、调试（跨语言调试、线程级可视化调试）、静态检查、性能分析、包管理、文档生成、Mock工具、测试框架、覆盖率工具、Fuzz工具以及智能辅助编程工具，进一步提升软件开发体验以及效率。以下我们将围绕上述几个方面介绍仓颉语言的主要特性，让读者能够快速了解仓颉语言的定位和主要技术特色。</p>
<h2 id="高效编程"><a href="#高效编程" class="headerlink" title="高效编程"></a>高效编程</h2><p>仓颉支持面向对象、函数式、命令式等多种编程范式的融合，既支持面向对象编程范式的模块化和灵活性，又支持函数式编程范式的简洁性和高抽象级表达，使得开发者能够根据业务需求，选择最合适的表达方式，简洁高效地开发业务代码。</p>
<p>除此以外，仓颉还借鉴了现代语言中的各种优秀语言特性，包括各种声明式语法和语法糖，除了能让通用场景的编程更加简洁，还可以针对特定场景快速设计领域特定语言（DSL），以提升领域易用性。</p>
<h3 id="多范式"><a href="#多范式" class="headerlink" title="多范式"></a>多范式</h3><p>仓颉是一个典型的多范式编程语言，对过程式编程、面向对象编程和函数式编程都提供了良好的支持，包括值类型、类和接口、泛型、代数数据类型和模式匹配，以及函数作为一等公民等特性支持。</p>
<h4 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h4><p>仓颉支持使用传统的类（class）和接口（interface）来实现面向对象范式编程。仓颉语言只允许单继承，每个类只能有一个父类，但可以实现多个接口。每个类都是Object的子类（直接子类或者间接子类）。此外，所有的仓颉类型（包括Object）都隐式的实现Any接口。</p>
<p>仓颉提供open修饰符，来控制一个类能不能被继承，或者一个对象成员函数能不能被子类重写（override）。</p>
<p>在下面的例子中，类B继承了类A，且同时实现了接口I1和I2。为了让A能够被继承，它的声明需要被open修饰。类A中的函数f也被open修饰，因此可以在B中被重写。对函数f的调用会根据对象具体的类型来决定执行哪个版本，即<strong>动态派遣</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    let x: Int = 1</span><br><span class="line">    var y: Int = 2</span><br><span class="line">    </span><br><span class="line">    open func f()&#123;</span><br><span class="line">        println(&quot;function f in A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func g()&#123;</span><br><span class="line">        println(&quot;function g in A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface I1 &#123;</span><br><span class="line">    func h1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I2 &#123;</span><br><span class="line">    func h2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &lt;: A &amp; I1 &amp; I2 &#123;</span><br><span class="line">    override func f()&#123;</span><br><span class="line">        println(&quot;function f in B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func h1()&#123;</span><br><span class="line">        println(&quot;function h1 in B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func h2()&#123;</span><br><span class="line">        println(&quot;function h2 in B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    let o1: I1 = B()</span><br><span class="line">    let o2: A = A()</span><br><span class="line">    let o3: A = B()</span><br><span class="line"></span><br><span class="line">    o1.h1() // &quot;function h1 in B&quot;</span><br><span class="line">    o2.f()  // &quot;function f in A&quot;</span><br><span class="line">    o3.f()  // 动态派遣，&quot;function f in B&quot;</span><br><span class="line">    o3.g()  // &quot;function g in A&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仓颉的interface之间也可以继承，并且不受单继承的约束，即一个interface也可以继承多个父 interface。如下示例，I3可以同时继承I1和I2。因此，若要实现I3，需要提供对f、g和h三个函数的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface I1 &#123;</span><br><span class="line">    func f(x: Int): Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I2 &#123;</span><br><span class="line">    func g(x: Int): Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface I3 &lt;: I1 &amp; I2 &#123;</span><br><span class="line">    func h(): Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="函数作为一等公民-what"><a href="#函数作为一等公民-what" class="headerlink" title="函数作为一等公民(what?)"></a>函数作为一等公民(what?)</h4><p>仓颉中函数可以作为普通表达式使用，可以作为参数传递，作为函数返回值，被保存在其他数据结构中，或者赋值给一个变量使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func f(x: Int) &#123;</span><br><span class="line">    return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = f</span><br><span class="line"></span><br><span class="line">let square = &#123;x: Int =&gt; x * x&#125; // lambda 表达式</span><br><span class="line"></span><br><span class="line">// 函数嵌套定义，以及函数作为返回值</span><br><span class="line">func g(x: Int) &#123;</span><br><span class="line">    func h()&#123;</span><br><span class="line">        return f(square(x))</span><br><span class="line">    &#125;</span><br><span class="line">    return h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func h(f: ()-&gt;Unit) &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = h(g(100))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了上面例子中的全局函数，对象或结构体等数据类型的成员函数同样也可以作为一等公民使用。下面的例子中，对象o的成员函数resetX作为普通表达式被赋值给变量f，对f的调用则会改变对象o中成员变量x的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    var x = 100</span><br><span class="line">    func resetX(n: Int) &#123;</span><br><span class="line">        x = n</span><br><span class="line">        return x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    let o = C()</span><br><span class="line">    let f = o.resetX // 成员函数作为一等公民</span><br><span class="line">    f(200)</span><br><span class="line">    print(o.x) // 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代数数据类型和模式匹配"><a href="#代数数据类型和模式匹配" class="headerlink" title="代数数据类型和模式匹配"></a>代数数据类型和模式匹配</h4><p>代数数据类型是一种复合类型，指由其它数据类型组合而成的类型。两类常见的代数类型是<strong>积类型</strong>（如struct、tuple等）与<strong>和类型</strong>（如tagged union）。</p>
<p>在此我们着重介绍仓颉的和类型enum，以及对应的模式匹配能力。</p>
<p>在下面的例子中，enum类型BinaryTree具有两个构造器，Node和Empty。其中Empty不带参数，对应于只有一个空节点的二叉树，而Node需要三个参数来构造出一个具有一个值和左右子树的二叉树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum BinaryTree &#123;</span><br><span class="line">    | Node(value: Int, left: BinaryTree, right: BinaryTree)</span><br><span class="line">    | Empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问这些enum实例的值需要使用<strong>模式匹配</strong>进行解析。模式匹配是一种测试表达式是否具有特定特征的方法，在仓颉中主要提供了match表达式来完成这个目标。对于给定的enum类型的表达式，我们使用match表达式来判断它是用哪个构造器构造的，并提取相应构造器的参数。下面的例子中，递归函数sumBinaryTree实现对二叉树节点中保存的整数求和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sumBinaryTree(bt: BinaryTree) &#123;</span><br><span class="line">    match (bt) &#123;</span><br><span class="line">        case Node(v, l, r) =&gt; </span><br><span class="line">            v + sumBinaryTree(l) + sumBinaryTree(r)</span><br><span class="line">        case Empty =&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此enum模式以外，仓颉也提供了其它各种模式，如常量模式、绑定模式、类型模式等，以及各种模式的嵌套使用。在下面的例子中，我们给出了对应模式的使用：</p>
<ul>
<li>常量模式：可以使用多种字面量值进行判等比较，如整数、字符串等。</li>
<li>绑定模式：可以将指定位置的成员绑定到新的变量，多用于解构 enum 或 tuple。上面的sumBinaryTree例子中就用到了绑定模式，将Node节点中实际的参数与三个新声明的变量v、l和r分别绑定。</li>
<li>类型模式：可以用于匹配是否目标类型，多用于向下转型。</li>
<li>tuple模式：用于比较或者解构tuple。</li>
<li>通配符模式：用于匹配任何值。</li>
</ul>
<p>未来仓颉还计划引入更加丰富的模式，如序列（sequence）模式、record模式等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 常量模式-字符串字面量</span><br><span class="line">func f1(x: String) &#123;</span><br><span class="line">    match (x) &#123;</span><br><span class="line">        case &quot;abc&quot; =&gt; ()</span><br><span class="line">        case &quot;def&quot; =&gt; ()</span><br><span class="line">        case _ =&gt; () // 通配符模式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// tuple 模式</span><br><span class="line">func f2(x: (Int, Int)) &#123;</span><br><span class="line">    match (x) &#123;</span><br><span class="line">        case (_, 0) =&gt; 0  // 通配符模式和常量模式</span><br><span class="line">        case (i, j) =&gt; i / j // 绑定模式，将 x 的元素绑定到 i 和 j 两个变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类型模式</span><br><span class="line">func f3(x: ParentClass) &#123;</span><br><span class="line">    match (x) &#123;</span><br><span class="line">        case y: ChildClass1 =&gt; ... </span><br><span class="line">        case y: ChildClass2 =&gt; ...</span><br><span class="line">        case _ =&gt; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在现代软件开发中，泛型编程已成为提高代码质量、复用性和灵活性的关键技术。泛型作为一种参数化多态技术，允许开发者在定义类型或函数时使用类型作为参数，从而创建可适用于多种数据类型的通用代码结构。泛型带来的好处包括：</p>
<ul>
<li>代码复用：能够定义可操作多种类型的通用算法和数据结构，减少代码冗余。</li>
<li>类型安全：支持更多的编译时的类型检查，避免了运行时类型错误，增强了程序的稳定性。</li>
<li>性能提升：由于避免了不必要的类型转换，泛型还可以提高程序执行效率。<br>仓颉支持泛型编程，诸如函数、struct、class、interface、extend 都可以引入泛型变元以实现功能的泛型化。数组类型在仓颉中就是典型的泛型类型应用，其语法表示为 Array<T>，其中 T 表示了元素的类型，可以被实例化为任何一个具体的类型，例如 Array<Int> 或 Array<String>，甚至可以是嵌套数组 Array&lt;Array<Int>&gt;，从而可以轻易地构造各种不同元素类型的数组。</Int></String></Int></T></li>
</ul>
<p>除了类型外，我们还可以定义<strong>泛型函数</strong>。例如我们可以为使用泛型函数来实现任意两个同类型数组的 concat 操作。如下代码所示，我们定义了一个泛型函数 concat，并且它支持任意两个 Array<T> 类型的数组参数，经过处理后返回了一个拼接后的新数组。这样定义的 concat 函数可以应用在 Array<Int>、Array<String>、Array&lt;Array<Int>&gt; 以及其它任意类型的数组上，实现了功能的通用化。</Int></String></Int></T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func concat&lt;T&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;): Array&lt;T&gt; &#123;</span><br><span class="line">    let defaultValue = if (lhs.size &gt; 0) &#123;</span><br><span class="line">        lhs[0]</span><br><span class="line">    &#125; else if (rhs.size &gt; 0) &#123;</span><br><span class="line">        rhs[0]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    let newArr = Array&lt;T&gt;(lhs.size + rhs.size, item: defaultValue)</span><br><span class="line">    // 使用数组切片进行整段拷贝</span><br><span class="line">    newArr[0..lhs.size] = lhs</span><br><span class="line">    newArr[lhs.size..rhs.size] = rhs</span><br><span class="line">    return newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型和接口以及子类型结合使用，还可以让我们对泛型中的类型变元给出具体的约束，从而对可以实例化该类型变元的实际类型做出限制。下面的例子中，我们希望在数组arr查找元素element。虽然我们并不关心数组及其元素的具体类型，但元素类型T必须能够支持判等操作，让我们能够比较数组中的元素与给定元素是否相等。因此，在lookup函数中的where子句中，我们要求T &lt;: Equatable<T>，即类型T必须实现了接口Equatable<T>。</T></T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func lookup&lt;T&gt;(element: T, arr: Array&lt;T&gt;): Bool where T &lt;: Equatable&lt;T&gt; &#123;</span><br><span class="line">    for (e in arr)&#123;</span><br><span class="line">        if (element == e)&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仓颉的泛型类型不支持协变。以数组为例，不同元素类型的数组是完全不相同的类型，它们之间不能互相赋值，哪怕元素类型之间具有父子类型关系也是禁止的。这避免了数组协变导致的类型不安全问题。</p>
<p>如下示例所示，Apple 是 Fruit 的子类，但是变量 a 和变量 b 之间是不能互相赋值的，Array<Fruit> 和 Array<Apple> 之间没有子类型关系。</Apple></Fruit></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open class Fruit &#123;&#125;</span><br><span class="line">class Apple &lt;: Fruit &#123;&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    var a: Array&lt;Fruit&gt; = []</span><br><span class="line">    var b: Array&lt;Apple&gt; = []</span><br><span class="line">    a = b // 编译报错</span><br><span class="line">    b = a // 编译报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h3><p>仓颉支持类型扩展特性，允许我们在不改变原有类型定义代码的情况下，为类型增加成员函数等功能。具体来说，</p>
<p>仓颉的类型扩展可以对已有的类型做如下几类扩展：</p>
<ul>
<li>添加函数</li>
<li>添加属性</li>
<li>添加操作符重载</li>
<li>实现接口</li>
</ul>
<p>下面的例子中，我们为String类型增加了printSize成员函数，因此在下面的代码中就可以像调用其他预定义的成员函数一样来调用printSize。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extend String &#123;</span><br><span class="line">    func printSize() &#123;</span><br><span class="line">        print(this.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;123&quot;.printSize() // 3</span><br></pre></td></tr></table></figure>

<p>而当扩展和接口搭配使用的时候，它更能大幅提升语言的表达能力，我们甚至可以给已有的类型添加新的继承体系。</p>
<p>在下面的例子中，我们可以定义一个新接口Integer，然后用extend给已有的整数类型实现 Integer 接口，这样已有的整数类型就自然成为了 Integer 的子类型。其中sealed修饰符表示该接口只能在当前包中被实现（或扩展）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sealed interface Integer &#123;&#125;</span><br><span class="line"></span><br><span class="line">extend Int8 &lt;: Integer &#123;&#125;</span><br><span class="line">extend Int16 &lt;: Integer &#123;&#125;</span><br><span class="line">extend Int32 &lt;: Integer &#123;&#125;</span><br><span class="line">extend Int64 &lt;: Integer &#123;&#125;</span><br><span class="line"></span><br><span class="line">let a: Integer = 123 // ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>类型推断是指由编译器根据程序上下文自动推断变量或表达式的类型，而无需开发者显式写出。</p>
<p>仓颉作为现代编程语言，对类型推断也提供了良好的支持。</p>
<p>在仓颉中变量的定义可以根据初始化表达式的类型来推断其类型。除了变量以外，仓颉还额外支持了函数定义返回值类型的推断。在仓颉中，函数体的最后一个表达式会被视为这个函数的返回值。像变量一样，当函数定义省略了返回类型，函数就会通过返回值来推断返回类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = 123 // foo 是 &#x27;Int64&#x27;</span><br><span class="line">var bar = &#x27;hello&#x27; // bar 是 &#x27;String&#x27;</span><br><span class="line"></span><br><span class="line">func add(a: Int, b: Int) &#123; // add 返回 Int</span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仓颉还支持在泛型函数调用中推断类型参数，包括对柯里化函数里泛型参数的推断，如下面的例子所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func map&lt;T, R&gt;(f: (T)-&gt;R): (Array&lt;T&gt;)-&gt;Array&lt;R&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map(&#123; i =&gt; i.toString() &#125;)([1, 2, 3]) // 支持推断泛型柯里化函数</span><br><span class="line">// 推断结果为map&lt;Int, String&gt;(&#123; i =&gt; i.toString() &#125;)([1, 2, 3])</span><br></pre></td></tr></table></figure>

<p>注意lambda表达式作为map的第一个参数，它的参数类型（T）和返回值类型（R）都可以被推断出来，尽管参数类型（T）的推断还反过来依赖对map的第二个参数的类型（Array<T>）的推断。</T></p>
<h3 id="其他现代特性及语法糖"><a href="#其他现代特性及语法糖" class="headerlink" title="其他现代特性及语法糖"></a>其他现代特性及语法糖</h3><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>仓颉允许在同一作用域内定义多个同名函数。编译器根据参数的个数和类型，来决定函数调用实际执行的是哪个函数。例如，下面的绝对值函数，为每种数值类型都提供了对应的实现，但这些实现都具有相同的函数名abs，从而让函数调用更加简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func abs(x: Int64): Int64 &#123; ... &#125;</span><br><span class="line">func abs(x: Int32): Int32 &#123; ... &#125;</span><br><span class="line">func abs(x: Int16): Int16 &#123; ... &#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><p>命名参数是指在调用函数时，提供实参表达式的同时，还需要同时提供对应形参的名字。使用命名参数可以提升程序的可读性，减少参数的顺序依赖性，让程序更加易于扩展和维护。</p>
<p>在仓颉中，函数定义时通过在形参名后添加 ! 来定义命名参数。当形参被定义为命名参数后，调用这个函数时就必须在实参值前指定参数名，如下面的例子所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func dateOf(year!: Int, month!: Int, dayOfMonth!: Int) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">dateOf(year: 2024, month: 6, dayOfMonth: 21)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>仓颉的函数定义中，可以为特定形参提供默认值。函数调用时，如果选择使用该默认值做实参，则可以省略该参数。</p>
<p>这个特性可以减少很多函数重载或者引入建造者模式的需求，降低代码复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func dateOf(year!: Int64, month!: Int64, dayOfMonth!: Int64, timeZone!: TimeZone = TimeZone.Local) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dateOf(year: 2024, month: 6, dayOfMonth: 21) // ok</span><br><span class="line">dateOf(year: 2024, month: 6, dayOfMonth: 21, timeZone: TimeZone.UTC) // ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="尾随lambda（trailing-lambda）"><a href="#尾随lambda（trailing-lambda）" class="headerlink" title="尾随lambda（trailing lambda）"></a>尾随lambda（trailing lambda）</h4><p>仓颉支持尾随lambda语法糖，从而更易于DSL中实现特定语法。具体来说，很多语言中都内置提供了如下经典的条件判断或者循环代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(x &gt; 0)&#123;</span><br><span class="line">    x = -x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(x &gt; 0)&#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尾随lambda则能够让DSL开发者定制出类似的代码块语法，而无需在宿主语言中内置。例如，在仓颉中，我们支持下面这种方式的函数调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func unless(condition: Bool, f: ()-&gt;Unit) &#123;</span><br><span class="line">    if(!condition) &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = f(...)</span><br><span class="line">unless(a &gt; 0) &#123;</span><br><span class="line">    print(&quot;no greater than 0&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里对unless函数的调用看上去像是一种特殊的if表达式，这种语法效果是通过尾随lambda语法实现 —— 如果函数的最后一个形参是函数类型，那么实际调用这个函数时，我们可以提供一个lambda表达式作为实参，并且把它写在函数调用括号的外面。尤其当这个lambda表达式为无参函数时，我们允许省略lambda表达式中的双箭头&#x3D;&gt;，将其表示为代码块的形式，从而进一步减少对应DSL中的语法噪音。因此，在上面的例子中，unless调用的第二个实参就变成了这样的lambda表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; print(&quot;no greater than 0&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p>如果函数定义只有一个参数，并且该参数是函数类型，我们使用尾随lambda调用该函数时还可以进一步省略函数调用的括号，从而让代码看上去更简洁自然。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func runLater(fn:()-&gt;Unit) &#123;</span><br><span class="line">    sleep(5 * Duration.Second)</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runLater() &#123; // ok</span><br><span class="line">    println(&quot;I am later&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runLater &#123; // 可以进一步省略括号</span><br><span class="line">    println(&quot;I am later&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="管道（Pipeline）操作符"><a href="#管道（Pipeline）操作符" class="headerlink" title="管道（Pipeline）操作符"></a>管道（Pipeline）操作符</h4><p>仓颉中引入管道（Pipeline）操作符，来简化嵌套函数调用的语法，更直观的表达数据流向。下面的例子中，给出了嵌套函数调用和与之等效的基于管道操作符|&gt;的表达式。后者更加直观的反映了数据的流向：|&gt;左侧的表达式的值被作为参数传递给右侧的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func double(a: Int) &#123;</span><br><span class="line">    a * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func increment(a: Int) &#123;</span><br><span class="line">    a + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double(increment(double(double(5)))) // 42</span><br><span class="line"></span><br><span class="line">5 |&gt; double |&gt; double |&gt; increment |&gt; double // 42</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>仓颉中定义了一系列使用特殊符号表示的操作符，其中大多数操作符都允许被重载，从而可以作用在开发者自己定义的类型上，为自定义类型的操作提供更加简洁直观的语法表达。</p>
<p>在仓颉中只需要定义操作符重载函数就能实现操作符重载。在下面的例子中，我们首先定义一个类型Point表示二维平面中的点，然后我们通过重载+操作符，来定义两个点上的加法操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    let x: Int</span><br><span class="line">    let y: Int</span><br><span class="line"></span><br><span class="line">    init(x: Int, y: Int) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    operator func +(rhs: Point): Point &#123;</span><br><span class="line">        return Point(</span><br><span class="line">            this.x + rhs.x,</span><br><span class="line">            this.y + rhs.y</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: Point = ...</span><br><span class="line">let b: Point = ...</span><br><span class="line">let c = a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="属性（property）"><a href="#属性（property）" class="headerlink" title="属性（property）"></a>属性（property）</h4><p>在面向对象范式中，我们常常会将成员变量设计为private的，而将成员变量的访问封装成getter和setter两种public方法。</p>
<p>这样可以隐藏数据访问的细节，从而更容易实现访问控制、数据监控、跟踪调试、数据绑定等业务策略。</p>
<p>仓颉中直接提供了属性这一种特殊的语法，它使用起来就像成员变量一样可以访问和赋值，但内部提供了getter和setter来实现更丰富的数据操作。对成员变量的访问和赋值会被编译器翻译为对相应getter和setter成员函数的调用。</p>
<p>具体来说，prop 用于声明只读属性，只读属性只具有 getter 的能力，必须提供 get 实现；mut prop 用于声明可变属性。可变属性同时具备 getter 和 setter 的能力，必须提供 get 和 set 实现。</p>
<p>如下示例所示，开发者希望对 Point 类型的各数据成员的访问进行记录，则可以在内部声明 private 修饰的成员变量，通过声明对应的属性来对外暴露访问能力，并在访问的时候使用日志系统Logger记录它们的访问信息。对使用者来说，使用对象p的属性与访问它的成员变量一样，但内部却实现了记录的功能。</p>
<p>注意这里x和y是只读的，只有get实现，而color则是可变的，用mut prop修饰，同时具有get和set实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    private let _x: Int</span><br><span class="line">    private let _y: Int</span><br><span class="line">    private var _color: String</span><br><span class="line"></span><br><span class="line">    init(x: Int, y: Int, color: String) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    prop x: Int &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            Logger.log(level: Debug, &quot;access x&quot;)</span><br><span class="line">            return _x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop y: Int &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            Logger.log(level: Debug, &quot;access y&quot;)</span><br><span class="line">            return _y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mut prop color: String &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            Logger.log(level: Debug, &quot;access color&quot;)</span><br><span class="line">            return _color</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set(c) &#123;</span><br><span class="line">            Logger.log(level: Debug, &quot;reset color to $&#123;c&#125;&quot;)</span><br><span class="line">            color = c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    let p = Point(0, 0, &quot;red&quot;)</span><br><span class="line">    let x = p.x // &quot;access x&quot;</span><br><span class="line">    let y = p.y // &quot;access y&quot;</span><br><span class="line">    p.color = &quot;green&quot; // &quot;reset color to green&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="安全可靠"><a href="#安全可靠" class="headerlink" title="安全可靠"></a>安全可靠</h2><p>编程语言的设计和实现，以及相应工具支持，对于程序质量和安全性有重要影响。</p>
<p>仓颉通过静态类型系统、动静态检查、自动内存管理、以及工具链来提升程序的安全性。</p>
<h3 id="静态类型和垃圾收集"><a href="#静态类型和垃圾收集" class="headerlink" title="静态类型和垃圾收集"></a>静态类型和垃圾收集</h3><p>仓颉是静态类型语言，程序中所有变量和表达式的类型都是在编译期确定的，并且在程序运行过程中不会发生改变。相比动态类型系统，静态类型系统对开发者有更多的约束，但能够在编译期尽量早的发现程序中的错误，提高程序的安全性，同时也让程序的行为更加容易预测，为编译优化提供了更多信息，使能更多的编译优化，提升程序的性能。</p>
<p>垃圾收集（GC）是一种自动内存管理机制，它能够自动识别和回收不再需要使用的对象，将开发者从手工释放内存中解放出来，不仅可以提高开发效率，还能有效避免各种常见内存错误，提升程序的安全性。常用的垃圾收集技术包括tracing和引用计数（reference counting，即RC）。仓颉采用tracing GC技术，通过在运行时跟踪对象之间的引用关系，来识别活动对象和垃圾对象。</p>
<h3 id="空引用安全"><a href="#空引用安全" class="headerlink" title="空引用安全"></a>空引用安全</h3><p>空引用是指引用类型的值可以为 null。代码存在空引用会引发各种各样潜在的风险，空引用被图灵奖得主Tony Hoare称为“价值十亿美元的错误”。</p>
<p>在许多编程语言中，空引用都是最常见的陷阱之一，开发者很容易在未确保非空的情况下访问引用类型的成员，从而引发错误或异常。因为语言类型系统并未给非空引用类型提供任何保障。</p>
<p>空引用安全就是旨在消除代码空引用危险。</p>
<p>仓颉是实现了空引用安全的语言之一。在仓颉中，没有提供 null 值，换句话说，仓颉的引用类型永远是非空的。从而在类型上杜绝了空引用的发生。</p>
<p>值得注意的是，表示一个空值在语义中是十分有用的。在仓颉中，对于任意类型T，都可以有对应的可选类型Option<T>。具有Option<T>类型的变量要么对应一个实际的具有T类型的值v，因此取值为Some(v)，要么具有空值，取值为None。</T></T></p>
<p>可选类型（Option<T>）是一种 enum 类型，是一个经典的代数数据类型，表示有值或空值两种状态。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T) | None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a: Option&lt;Int&gt; = Some(123)</span><br><span class="line">a = None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意Option<T>和T是两个不同的类型，具有两种类型的值之间不能互相转换 —— 给定一个Option<T>类型的表达式e，我们只有通过模式匹配确定其值为Some(v)时（也就是说其值非空），才可以得到一个T类型的值v。因此，对表达式e的任意有意义的处理，必需伴随着模式匹配和对应的判空操作，从而不可能直接对空值None做解引用，避免了空引用异常。</T></T></p>
<p>基于可选类型使用的广泛性，仓颉还为可选类型提供了丰富的语法糖支持。例如可以使用 ?T 来代替 Option<T>，也提供了可选链操作符（?.）来简化成员访问，以及空合并操作符（??）来合并有效值。</T></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a: ?Int = None</span><br><span class="line">a?.toString() // None</span><br><span class="line">a ?? 123 // 123</span><br><span class="line">a = Some(321)</span><br><span class="line">a?.toString() // Some(&quot;321&quot;)</span><br><span class="line">a ?? 123 // 321</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型是一种具有传递即复制的语义行为的类型，具有值类型的变量，其中保存的是数据自身，而不是指向数据的引用。由于值类型的这种特性，开发者选择性地使用值类型可以使得程序显著减少修改语义，从而让程序变得更可预测、更可靠。</p>
<p>例如最典型的并发安全问题就是在程序不同的线程中传递了同一个可变对象，此时访问这个对象的字段将会造成不可预测的 data race 问题。如果这个对象具备值语义，那么在传递的过程中我们就可以保证它经过了完整的复制，让每个线程对该值的访问都是彼此独立的，从而保证了并发安全。</p>
<p>仓颉原生支持了值类型，除了常见的 Int 类型以外，仓颉也可以使用 struct 来实现用户自定义的值类型。</p>
<p>如下面的例子，Point 正是一个值类型，因此在经过赋值后，a 和 b 已经是两个彼此独立的变量，对 a 的修改不会影响到 b。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">    init(x: Int, y: Int) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = Point(0, 0)</span><br><span class="line">var b = a</span><br><span class="line">a.x = 1</span><br><span class="line">print(b.x) // 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="“不可变”优先"><a href="#“不可变”优先" class="headerlink" title="“不可变”优先"></a>“不可变”优先</h3><p>不可变（Immutable）指的是在变量赋值或对象创建结束之后，使用者就不能再改变它的值或状态。不可变意味着只读不写，因此不可变对象天然地具备线程安全的特性，即如无其它特殊限制的话可以在任何线程上自由调用。此外，相较于可变对象，不可变对象的访问没有副作用，因此在一些场合下也会让程序更易于了解，而且提供较高的安全性。</p>
<p>不可变通常可以分为两种，一种是不可变变量，不可变变量是指经初始化后其值就不可被修改的变量；另一种是不可变类型，不可变类型是指在构造完成后实际数据对象的内容无法被改变。</p>
<p>在仓颉中，let定义的变量是不可变变量，而像 String、enum 等类型是不可变类型，这些都是不可变思想在仓颉中的应用。更多地使用不可变特性可以让程序更安全，也更利于理解和维护。</p>
<h4 id="函数参数不可变"><a href="#函数参数不可变" class="headerlink" title="函数参数不可变"></a>函数参数不可变</h4><p>在仓颉中，所有函数形参都是不可变的，这意味着我们无法对形参赋值，如果形参是值类型，也无法修改形参的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line">    init(x: Int, y: Int) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f(a: Point) &#123;  // a 不可变</span><br><span class="line">    a = Point(0, 0) // error</span><br><span class="line">    a.x = 2 // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模式匹配引入的新变量不可变"><a href="#模式匹配引入的新变量不可变" class="headerlink" title="模式匹配引入的新变量不可变"></a>模式匹配引入的新变量不可变</h4><p>在仓颉中，模式匹配支持变量绑定模式，我们可以将目标值解析到新绑定的变量中，但这个变量仍然是不可变的。这意味着我们无法对绑定的变量赋值，如果变量是值类型，也无法修改变量的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func f(a: ?Point) &#123;</span><br><span class="line">    match (a) &#123;</span><br><span class="line">        case Some(b) =&gt;  //b 不可变</span><br><span class="line">            b = Point(0, 0) // error</span><br><span class="line">            b.x = 2 // error</span><br><span class="line">        case None =&gt;</span><br><span class="line">            ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="闭包捕获可变变量不允许逃逸"><a href="#闭包捕获可变变量不允许逃逸" class="headerlink" title="闭包捕获可变变量不允许逃逸"></a>闭包捕获可变变量不允许逃逸</h4><p>在仓颉中，闭包指的自包含的函数或 lambda，闭包可以从定义它的静态作用域中捕获变量，即使对闭包调用不在定义的作用域，仍可以访问其捕获的变量。</p>
<p>仓颉中允许闭包捕获可变变量，但不允许该闭包继续逃逸，这避免了对可变变量修改可能导致的意外行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func f() &#123;</span><br><span class="line">    let a = 1</span><br><span class="line">    var b = 2</span><br><span class="line">    func g() &#123;</span><br><span class="line">        print(a) // ok</span><br><span class="line">        print(b) // ok</span><br><span class="line">    &#125;</span><br><span class="line">    return g // error, g 捕获了可变变量 b，g 不允许作为表达式使用。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="默认封闭"><a href="#默认封闭" class="headerlink" title="默认封闭"></a>默认封闭</h3><p>仓颉虽然支持了完整的面向对象范式，支持了类继承的特性，但仓颉并不鼓励滥用继承，尤其是默认可继承可覆盖。默认可继承语义会使得开发者设计的库无意间被使用者增加了抽象层次，提升了不必要的复杂性，从而引起一系列工程维护问题。</p>
<p>出于工程友好性的考虑，仓颉采取了默认封闭的设计选择，即类默认不可被继承，方法默认也不可被覆盖（override）。开发者需要主动考虑是否需要自己的类型提供子类的能力，通过这样的约束减少了滥用继承的现象。</p>
<h4 id="类默认不可继承"><a href="#类默认不可继承" class="headerlink" title="类默认不可继承"></a>类默认不可继承</h4><p>在仓颉中，开发者定义class时默认是不可继承的。如果希望该class有子类，必须显式使用open、abstract、sealed其中一个修饰（这些修饰符的语义有细微差别，但都允许class被继承）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B &lt;: A &#123;&#125; // error，A 不允许被继承</span><br><span class="line">open class C &#123;&#125;</span><br><span class="line">class D &lt;: C &#123;&#125; // ok</span><br></pre></td></tr></table></figure>

<h4 id="成员方法默认不可覆盖"><a href="#成员方法默认不可覆盖" class="headerlink" title="成员方法默认不可覆盖"></a>成员方法默认不可覆盖</h4><p>在仓颉中，开发者定义成员方法默认是不可覆盖（override）的。这意味着即使该类拥有子类，子类也无法修改该成员方法。如果希望一个成员方法可以被覆盖，必须显式使用 open 修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    func f() &#123;&#125;</span><br><span class="line">    open func g() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &lt;: A &#123;</span><br><span class="line">    override func f() &#123;&#125; // error，f 不允许被覆盖</span><br><span class="line">    override func g() &#123;&#125; // ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>仓颉使用try-catch-finally表达式来实现异常处理，该机制和传统语言的异常处理机制十分相似，但仓颉额外提供了try-with-resources表达式语法来自动释放非内存资源。</p>
<p>不同于普通try表达式，try-with-resources表达式中的catch块和finally块均是可选的，并且try关键字其后的块之间可以插入一个或者多个变量定义用来申请一系列的资源对象，这些资源对象在try-with-resources表达式中会被自动管理起来，当某个资源发生异常或表达式结束后都会自动释放，达到安全管理资源的目的。</p>
<p>如下实例所示，input和output变量会在try-with-resources表达式过程中自动管理，开发者不需要关注当中各种情况的资源释放问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (input = MyResource(),</span><br><span class="line">    output = MyResource()) &#123;</span><br><span class="line">    while (input.hasNextLine()) &#123;</span><br><span class="line">        let lineString = input.readLine()</span><br><span class="line">        output.writeLine(lineString)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里资源对象的类型（上面例子中的MyResource）必须已经实现了Resource接口，特别是已经实现了Resource接口中要求的isClosed和close函数，能够判别资源是否已经被释放，以及做对应的释放操作。编译器将会在发生异常时或者try代码块正常结束时，插入对相应函数的调用，自动释放资源。</p>
<h3 id="动态安全检查"><a href="#动态安全检查" class="headerlink" title="动态安全检查"></a>动态安全检查</h3><p>除了静态类型给我们提供的安全保证以外，仓颉同时也非常重视运行时的安全检查，对于一些不适合使用静态类型的场景，仓颉也提供了运行时检查的安全保证。</p>
<h4 id="溢出检查"><a href="#溢出检查" class="headerlink" title="溢出检查"></a>溢出检查</h4><p>不同于大多数传统语言，在仓颉中的整数运算默认会进行溢出检查而不是任由其 wrapping。</p>
<p>当上下文足以静态分析的时候，整数溢出可提前在编译期检测出来，编译器会直接给出报错；当上下文不足以静态分析的时候，整数溢出会在运行时做一个检查，如果溢出会抛出运行时异常。</p>
<p>这个机制使得大多数时候，整数溢出都会及时被感知，避免造成业务隐患。</p>
<p>运行时检查会增加额外的计算开销，但经过仓颉编译器优化后可以将计算开销控制在一个较小的水平。</p>
<p>如果一些敏感场景希望通过接受 wrapping 的代价来换取更好的极限性能，也可以手动指定溢出策略来实现传统语言的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@OverflowWrapping</span><br><span class="line">func test(x: Int8, y: Int8) &#123; // if x equals to 127 and y equals to 3</span><br><span class="line">    let z = x + y // z equals to -126</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组越界检查"><a href="#数组越界检查" class="headerlink" title="数组越界检查"></a>数组越界检查</h4><p>同样的，在仓颉数组的下标访问中，对数组的下标越界访问也有安全检查。当上下文足以静态分析的时候，下标访问可提前在编译期检测出来，编译器会直接给出报错；当上下文不足以静态分析的时候，下标访问会在运行时做一个检查，如果溢出会抛出运行时异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func f(index: Int) &#123;</span><br><span class="line">    let a = [1, 2, 3]</span><br><span class="line">    let b = a[-1] // 编译期报错</span><br><span class="line">    let c = a[index] // 运行时检查</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>仓颉语言提供了多种混淆技术用于保护开发者的软件资产，提升攻击者逆向攻击仓颉软件的难度。攻击者可采用逆向工程技术对程序进行攻击，并获取程序的符号名、路径信息和行号信息、特征字符串和特征常数，以及控制流信息。仓颉混淆技术可以对这些信息进行混淆和隐藏，让攻击者难以借用这些信息辅助理解程序的运行逻辑。</p>
<ul>
<li><p>外形混淆：外形混淆可以混淆仓颉应用的符号名、路径信息和行号信息，并且对仓颉二进制中的函数进行重排。混淆后，攻击者无法再利用这些信息辅助理解程序的运行逻辑。使能外形混淆后，函数名和变量名被随机字符串替换、路径名被字符串“SOURCE”替换、行号被修改为0。</p>
</li>
<li><p>数据混淆：仓颉编译器支持字符串混淆和常量混淆。字符串混淆功能会识别代码中的明文字符串，将其加密保存。程序在初始化时会先解密字符串，再执行程序逻辑。因此，外部攻击者无法直接从程序文件中获取明文字符串，只能看到加密后的数据，因此无法根据字符串信息猜测代码逻辑。对于程序中使用的已知常量，仓颉编译器支持使用常量混淆功能，将使用这些常量的代码片段转化为等价的、更加难以理解的代码片段。</p>
</li>
<li><p>控制流混淆：仓颉编译器支持虚假控制流和控制流平坦化两种控制流混淆功能，在不影响程序正常执行的前提下，打乱、重排基本块之间的跳转关系，从而提升分析理解程序控制流的难度。虚假控制流的原理是在程序中随机添加大量虚假的条件跳转分支，并且这些条件跳转分支的条件变量都是由不透明谓词组成；控制流平坦化的主要目的是隐藏基本块之间的跳转关系，并确保在实际执行时基本块的执行顺序和混淆前一致，保证程序的正常功能不被影响，但攻击者无法静态根据控制流信息得到基本块之间的先后执行关系以及跳转关系。</p>
</li>
</ul>
<h3 id="消毒器"><a href="#消毒器" class="headerlink" title="消毒器"></a>消毒器</h3><p>消毒器是一种程序测试工具，通过插入检测代码来检测未定义或可疑行为形式的错误。仓颉支持多种类型的消毒器，仓颉在移动应用开发语言中率先支持基于硬件特性的地址消毒器。例如，使用直接映射的影子内存来检测内存损坏、缓冲区溢出或访问悬空指针（use-after-free）。</p>
<ul>
<li><p>基于软件算法的仓颉CFFI内存安全检测机制（地址消毒器）：仓颉语言的C语言互操作能力（CFFI）在与C&#x2F;C++代码进行交互的过程中，由于其可以与C&#x2F;C++代码进行不受限制的内存互访，C&#x2F;C++侧安全漏洞可能影响整体安全。仓颉提供基于软件实现的CFFI内存安全检测机制，提供仓颉代码与C&#x2F;C++代码交互过程中的内存安全检测能力，可以检测常见的空间内存安全问题（如堆、栈、全局变量溢出）和时间内存安全问题（如释放后使用、双重释放等）。</p>
</li>
<li><p>基于硬件特性的仓颉CFFI内存安全检测机制（硬件辅助的地址消毒器）：基于硬件实现的仓颉CFFI内存安全检测利用处理器能力，实现更高效地检测仓颉代码与C&#x2F;C++代码交互过程中的内存安全问题。相对于前述的软件CFFI内存安全检测机制，该机制可以检测更多内存安全问题，并且运行开销更低。</p>
</li>
<li><p>仓颉数据竞争安全检测（线程消毒器）：仓颉定义的数据竞争指两个协程对同一个数据访问，其中至少有一个是写操作，而且这两个操作之间没有happens-before关系。仓颉数据竞争安全检测使用happens-before和lock-set算法检测数据竞争问题。开发者可以通过仓颉编译器提供的sanitize&#x3D;thread选项使能该能力。</p>
</li>
</ul>
<h2 id="轻松并发"><a href="#轻松并发" class="headerlink" title="轻松并发"></a>轻松并发</h2><p>仓颉语言为并发编程提供了一种简单灵活的方式，通过轻量化线程模型和高效易用的无锁并发对象让并发编程变得轻松，将高效并发处理的能力直接置于开发者的手中。这一节将详细介绍仓颉并发编程两大关键技术的核心思想、设计、以及带来的显著优势，揭示仓颉语言如何实现“轻松并发”。</p>
<h3 id="轻量化线程模型"><a href="#轻量化线程模型" class="headerlink" title="轻量化线程模型"></a>轻量化线程模型</h3><p>仓颉语言采用用户态线程模型，在该模型下，每个仓颉线程都是极其轻量级的执行实体，拥有独立的执行上下文但共享内存。该模型不仅简化了开发者编写并发代码的过程，还带来了显著的性能优势。</p>
<ul>
<li><p>开发态：仓颉语言的线程模型使开发者能够像编写普通代码一样轻松地实现并发编程。通常，用户态线程模型可分为“无栈”和“有栈”两种实现方案。尽管“无栈”模型可以将内存占用降到极低，但其实现通常需要在语言中引入新语法，最常见的就是 async&#x2F;await 关键字。然而，这种新语法会显著增加开发者编写并发代码的复杂度。开发者不仅需要在编程过程中手动标记（如用 async 标记异步函数并用 await 标记其调用点），而且这种标记具有“传染性”（包含 await 的函数必须标记为 async），导致经典的“函数染色”问题。仓颉线程拥有独立的执行上下文，因此能够自由切换，开发者无需为标记操心，从而彻底消除这一复杂性。</p>
</li>
<li><p>运行态：与传统的操作系统线程相比，轻量化线程模型在性能上具有明显优势。由于其实现完全在用户空间进行，不依赖操作系统的线程管理，这从根本上减少了线程创建和销毁的开销，同时简化了线程调度流程。仓颉语言通过这种设计，实现了更高效的资源利用和更快的执行速度，尤其是在高并发场景下，这种优势更为显著。在一台常见的 x86 服务器上，仓颉线程创建的平均耗时为 700ns，这远小于操作系统线程的创建开销（操作系统线程的创建耗时量级一般为百微妙）。此外，一个仓颉线程仅占用 8Kb 内存资源，因此开发者可以在一个程序中同时创建十万级数量的仓颉线程，大大超出操作系统线程的限制。</p>
</li>
</ul>
<p>整体而言，仓颉语言的轻量化线程设计不仅降低系统的负担，而且使得开发者能够在不增加编程复杂度的前提下，轻松实现数千甚至数万个并发任务。其核心优势包括：</p>
<ul>
<li>简单的并发编程：不对开发者编写并发代码做过多语法约束，使其方便地使用仓颉线程并专注业务处理。</li>
<li>轻量级的开销：由于创建和切换用户态线程的开销远远小于传统的内核线程，仓颉语言可以快速地创建和销毁大量用户态线程，使得开发高并发应用变得轻而易举。</li>
<li>更高的并发能力：仓颉语言通过用户态线程模型，可以实现非常高的并发数，这使得它特别适合于I&#x2F;O密集型和高并发的网络服务场景。</li>
<li>减少上下文切换成本：在轻量化线程模型中，上下文切换发生在用户空间，避免了传统线程切换需要经过内核态和用户态之间频繁转换的高成本。</li>
</ul>
<p>基于这样的设计，在仓颉语言中，实现高效并发不再是一项复杂且耗时的任务。开发者可以通过简单的语法构造大量的用户态线程，无需担心传统并发模型中常见的性能瓶颈。假设我们有一个需求：需要同时处理多个网络请求。在仓颉语言中，这可以轻松实现，如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func fetch_data(url: String) &#123;</span><br><span class="line">    let response = http_get(url)</span><br><span class="line">    process(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    let urls = [&quot;https://example.com/data1&quot;, &quot;https://example.com/data2&quot;, ...]</span><br><span class="line">    let futures = ArrayList&lt;Future&lt;Unit&gt;&gt;()</span><br><span class="line">    for (url in urls) &#123;</span><br><span class="line">        let fut = spawn &#123; fetch_data(url) &#125;  // 创建仓颉线程进行网络请求</span><br><span class="line">        futures.append(fut)</span><br><span class="line">    &#125;</span><br><span class="line">    for (fut in futures) &#123;  // 等待所有仓颉线程完成</span><br><span class="line">        fut.get()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，spawn 关键字用于创建一个新的仓颉线程，每个线程独立地执行 fetch_data 函数。仓颉语言的运行时环境会自动调度这些线程，而开发者只需关注业务逻辑的实现。最后通过获取线程结果来等待所有的仓颉线程完成，确保主线程能够同步地获取所有结果。</p>
<p>仓颉语言的用户态线程模型以其显著的性能优势和轻量级的设计理念，为并发编程提供了一个颇具吸引力的新选择。它使得编写高并发应用变得更加直接和高效，不仅适用于高负载的网络服务，还能满足各种计算密集型任务的需要。通过这种新型并发模型，仓颉语言降低了并发编程的复杂性，同时还充分利用了现代多核处理器的强大能力。</p>
<h3 id="无锁并发对象"><a href="#无锁并发对象" class="headerlink" title="无锁并发对象"></a>无锁并发对象</h3><h2 id="卓越性能"><a href="#卓越性能" class="headerlink" title="卓越性能"></a>卓越性能</h2><p>仓颉语言通过值类型、多层级静态分析优化和超轻量运行时，在计算机语言基准测试Benchmarks Game上，相比业界同类语言取得了较为明显的性能优势。</p>
<h3 id="静态编译优化"><a href="#静态编译优化" class="headerlink" title="静态编译优化"></a>静态编译优化</h3><h3 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h3><h3 id="全并发整理GC"><a href="#全并发整理GC" class="headerlink" title="全并发整理GC"></a>全并发整理GC</h3><h3 id="轻量化运行时"><a href="#轻量化运行时" class="headerlink" title="轻量化运行时"></a>轻量化运行时</h3><p>仓颉语言提供了超轻量化的运行时，不但自身的分发开销低，也帮助应用以极低的开销部署和运行。</p>
<p>通过软件工程的优化手段，仓颉运行时库剔除了不必要的冗余代码，移除了对c++运行库的依赖，减少了外部可见符号的定义，其二进制体积达到了1MB量级。针对嵌入式的定制优化后的运行时共享库的体积更小，可以达到约500KB这个量级。</p>
<p>仓颉轻量化运行时支持用户态线程以极低的开销创建、运行和调度。用户态线程的创建耗时只需数百纳秒，用户代码执行栈内存仅有数KB，单次调度耗时只需数百纳秒。</p>
<p>仓颉轻量化运行时实现了仓颉语言与C语言互调的开销接近零成本。在底层实现上，仓颉语言的ABI定义与C语言高度兼容。仓颉语言支持的C兼容类型(通过“@C”关键字修饰)具有和C语言一致的内存布局，在典型场景里，仓颉语言与C语言数据可以实现无转换地共享。</p>
<p>仓颉轻量化运行时为开发者提供了灵活的应用剪裁技术，帮助开发者优化应用的包体积。仓颉语言的反射机制支持按需使能，可以在不需要时关闭反射能力。对于仓颉包内的私有方法可以通过函数粒度的按需链接清除冗余代码。</p>
<p>在轻量化运行时的帮助下，仓颉应用的部署和启动开销极低，应用启动时长在十毫秒级别，空载应用内存在1MB量级，在嵌入式场景里空载内存小于1MB。</p>
<h2 id="敏捷扩展"><a href="#敏捷扩展" class="headerlink" title="敏捷扩展"></a>敏捷扩展</h2><p>现代软件开发中，领域特定语言DSL由于其贴近领域问题，可以降低软件开发和维护的复杂度，因而承担了重要的作用。从DSL实现角度，内部DSL（embedded DSL，简称eDSL）是将一种现有的通用编程语言作为宿主语言，使用宿主语言提供的语言特性来扩展面向领域的语法，其相比完全独立构建DSL的实现方式（专门的语法解析、编译优化及配套工具等）具备以下优势：</p>
<ul>
<li>可复用宿主语言的语言特性，表达力强。</li>
<li>可复用宿主语言配套设施（库生态，编译工具，开发环境等），构建门槛低。</li>
<li>无缝嵌入到宿主语言工程中，可以高效的穿越“领域”进行数据交互。</li>
</ul>
<p>因而eDSL被广泛应用于各个领域，比如UI布局、数据库访问、云基础设施部署、编译脚本等场景。相应的，仓颉编程语言通过提供丰富的语言扩展能力，来支持面向领域的eDSL构建。</p>
<p>本章以下内容首先着重介绍仓颉提供语言扩展能力，包括基于原生语法的扩展能力，以及允许开发者构建新语法的元编程能力，最后以声明式UI为例介绍如何使用以上能力以及带来的效果。</p>
<h3 id="原生语法扩展能力"><a href="#原生语法扩展能力" class="headerlink" title="原生语法扩展能力"></a>原生语法扩展能力</h3><p>本节主要介绍一些仓颉原生语法特性在构建eDSL上的应用。使用这些语法来编写的代码，既是eDSL的程序，符合领域习惯，具有领域特定含义，又“天然”是合法的仓颉程序。这些语法大多在高效编程章节给出了介绍，这里我们重点介绍它们在构建eDSL中的作用。</p>
<h4 id="类型扩展和属性"><a href="#类型扩展和属性" class="headerlink" title="类型扩展和属性"></a>类型扩展和属性</h4><p>类型扩展允许我们在不侵入式修改原类型的前提下，为其添加新的功能，尤其是针对语言的原生类型，以及一些外部库定义的类型，这种扩展可以提高类型的易用性。属性机制可以为字段访问提供getter和setter支持，隐藏对数据访问的细节，但我们还可以像直接访问字段那样的语法来隐式调用getter和setter。这两种特性结合，就能写出一些能够自然表达领域含义的程序。例如在图书馆借书的场景，我们想把还书的时间设置为2周后的日期，构造一种类似自然语言的表达，那么期望写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bookReturnDate: DateTime = 2.weeks.later</span><br></pre></td></tr></table></figure>

<p>这里可以使用属性重新实现对Int64的扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extend Int64 &#123;</span><br><span class="line">    prop weeks: Int64 &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            this * 7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop later: DateTime &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            DateTime.now() + Duration.day * this</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="命名参数和参数默认值"><a href="#命名参数和参数默认值" class="headerlink" title="命名参数和参数默认值"></a>命名参数和参数默认值</h4><p>在构建eDSL时，需要针对一些对象进行参数配置，通常会遇到两类问题：</p>
<ul>
<li>配置参数较多，容易弄错顺序。</li>
<li>不希望每次把所有参数配置都写一遍，大多数情况下应该使用默认值。</li>
</ul>
<p>针对这种场景，可以结合命名参数和参数默认值的特性来解决，比如我们要设置在平面上所占的矩形区域的大小，需要确定其上下左右的位置，通常其上边和左边默认为0坐标，可以实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Rect &#123;</span><br><span class="line">    static func zone(top!: Int64 = 0, left!: Int64 = 0, bottom!: Int64, right!: Int64): Rect &#123;</span><br><span class="line">        // </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在使用时可以更清晰的进行矩形区域的配置，比如允许以下调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rect.zone(bottom: 10, right: 10) // top和left采用默认值</span><br><span class="line">Rect.zone(top: 5, bottom: 10, right: 10) // left采用默认值</span><br><span class="line">Rect.zone(right: 10, bottom: 10) // 无需记住参数顺序</span><br></pre></td></tr></table></figure>

<h4 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>操作符重载可以使一些非数值类型的对象，实现算数运算符的语法，比如在图书馆的例子中，之所以能写出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateTime.now() + Duration.day * this</span><br></pre></td></tr></table></figure>

<p>实际上是在仓颉标准库中，分别对DateTime的“+”操作和Duration的“*”操作进行重载，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//DateTime</span><br><span class="line">public operator func +(r: Duration): DateTime</span><br><span class="line"></span><br><span class="line">//Duration</span><br><span class="line">public operator func *(r: Int64): Duration</span><br></pre></td></tr></table></figure>

<h4 id="尾随lambda"><a href="#尾随lambda" class="headerlink" title="尾随lambda"></a>尾随lambda</h4><p>前文介绍了尾随lambda的概念，并从构建DSL的视角介绍了它的用途。这里我们再给出一个声明式UI中的例子，人们可以用尾随lambda表达组件间的分层关系，构造一种类似HTML的表达范式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Column &#123;</span><br><span class="line">    Image()</span><br><span class="line">    Row &#123;</span><br><span class="line">        Text()</span><br><span class="line">        Text()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Column其实是对名为Column函数的调用，而后面的花括号其实是仓颉的lambda表达式，是Column函数调用的参数，以尾随lambda的方式提供。Row中采用的也是同样的语法。</p>
<h4 id="关键字省略"><a href="#关键字省略" class="headerlink" title="关键字省略"></a>关键字省略</h4><p>eDSL的语法噪音是指由宿主语言引入，但又与领域实际的业务抽象无关的语法。语法噪音会影响eDSL的可读性。仓颉支持构造对象时省略new，允许行尾省略“;”，以及函数返回值省略return的能力，可以进一步简化eDSL表达，降低语法噪音。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>宏可以看作是一种“代码缩写”，也可以看做是一种扩展语言语法的方式。在编译或者程序运行过程中，看到这种代码缩写，会将其替换为实际对应的代码（即所谓的<strong>宏展开</strong>）。如果有些功能可以用统一且简单的代码来表达，那么就可以使用宏来处理。仓颉提供了在词法分析阶段做宏展开的<strong>过程宏</strong>，未来还将进一步提供更多简单易用且表达力丰富的宏定义方式，包括late-stage宏和模板宏等。</p>
<h4 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h4><p>仓颉的过程宏接受一个token序列作为输入，对齐进行处理和变换后，输出另一个token序列。输入的token序列由词法分析器产生，因此必须满足仓颉的词法规则，但无需满足仓颉的语法规则。输出的token序列必须满足仓颉的语法语义，是合法的仓颉程序。我们可以通过下面的例子来展示过程宏的工作原理。这里我们调用一个以expensiveComputation()作为参数的DebugLog 宏。这个宏在编译时会判断程序是配置在开发模式下运行还是在生产模式下运行。在开发模式下，会运行expensiveComputation()这样一个昂贵的诊断计算，并打印调试输出，以帮助发现和定位问题。在生产模式下，为了降低性能开销，我们不希望运行这个函数，也不会产生调试输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@DebugLog( expensiveComputation() )</span><br></pre></td></tr></table></figure>

<p>上述的宏DebugLog 可以这样实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public macro DebugLog(input: Tokens) &#123;</span><br><span class="line">    if (globalConfig.mode == Mode.development) &#123;</span><br><span class="line">        return quote( println( $&#123;input&#125; ) )</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return quote()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仓颉的宏定义语法与函数定义类似，其参数只能是token序列（即Tokens类型），其返回值是经过变换后的token序列。这个返回值就是宏调用（宏展开）后实际生成的代码。在上面的例子中，如果是在development模式下，返回值会在输入的token序列外面，加上println调用，因此除了执行input部分，还会把执行结果打印出来。如果不是development模式，则返回空序列，也就是完全忽略了input部分，不会生成任何代码。</p>
<h4 id="Late-stage宏和模板宏"><a href="#Late-stage宏和模板宏" class="headerlink" title="Late-stage宏和模板宏"></a>Late-stage宏和模板宏</h4><p>下面我们介绍两种正在开发中的宏定义，即<strong>Late-stage宏</strong>和<strong>模板宏</strong>，它们将在仓颉未来的版本中发布。</p>
<p>上述过程宏的输入token序列不包含程序的语义信息，但在某些情况下，我们希望在宏定义中根据有关变量的类型或类和接口声明的信息做出相应的处理，这种能力很难通过过程宏来实现。以下面的程序为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@FindType</span><br><span class="line">var x1: Employee = Employee(&quot;Fred Johnson&quot;)</span><br><span class="line">// getting the type info of `x1`: easy, it&#x27;s right there</span><br><span class="line"></span><br><span class="line">@FindType</span><br><span class="line">var x2 = Employee(&quot;Bob Houston&quot;)</span><br><span class="line">// getting the type info of `x2`: hard, requires type inference</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设宏FindType希望得到下面变量声明中变量的类型，并将其打印或加入日志。对于x1来说，它的类型（Employee）在语法中已经明确给出了，我们可以在输入的token序列中将其提取出来。然而，变量x2的类型在声明中并没有明确给出来，因此无法从输入token序列中直接得到。其类型信息需要靠类型推断计算出来，但宏展开是发生在语法分析阶段，类型推断还没有进行，因此我们还不具备相关信息。<strong>Late-stage宏</strong>通过将宏展开延迟到类型推断之后，能够获取并利用程序的各种语义信息，包括这种推断的类型信息。</p>
<p>Late-stage宏允许基于类型信息和代码中的非局部定义生成代码。这是一个强大的功能，它扩展了宏定义的处理能力。但它同时也是一个表达力更受限制的特性，因为在类型已知之后，对现有代码的根本更改不再是可能的。</p>
<p>如果我们希望对一些具有非常固定语法模式的代码做一些重写，那么<strong>模板宏</strong>会是比普通的过程宏更易用的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public template macro unless &#123;</span><br><span class="line">    template (cond: Expr, block: Block) &#123;</span><br><span class="line">        @unless (cond) block</span><br><span class="line">            =&gt;</span><br><span class="line">        if (! cond) block</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的模板宏定义将允许用户写出如下的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@unless (x &gt; 0) &#123;</span><br><span class="line">    print(&quot;x not greater than 0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏展开时将会根据上面模板宏的定义，匹配上面的模板，提取出cond和block，然后将其转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (! x &gt; 0) &#123;</span><br><span class="line">    print(&quot;x not greater than 0&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板宏的优点在于，它直接描述预期的源代码和目标代码，将重点放在关键代码段的转换上。虽然过程宏可以做同样的事情，但过程宏的定义会更加冗长且易出错。</p>
<h3 id="敏捷扩展案例：声明式UI"><a href="#敏捷扩展案例：声明式UI" class="headerlink" title="敏捷扩展案例：声明式UI"></a>敏捷扩展案例：声明式UI</h3><h2 id="工具支持"><a href="#工具支持" class="headerlink" title="工具支持"></a>工具支持</h2><p>仓颉开发者工具聚焦用户开发体验，围绕编译构建、调试、性能分析与LLT验证等开发流程，提供包管理器、调试器、原生测试框架、IDE等常用的开发工具，帮助开发者提升开发与问题定位效率。开发者工具从以下几方面显著提升开发效率，降低开发负担：</p>
<ul>
<li>包管理器：支持自动依赖管理和用户自定义构建，提供一站式编译构建能力；</li>
<li>调试器：支持跨语言调试和多线程调试，提升调试体验；</li>
<li>测试框架：包括单元测试框架、Mocking测试框架和基准测试框架；</li>
<li>IDE：开发者在VSCode底座以及Huawei DevEco Studio底座安装仓颉插件后，实现开箱即用。</li>
</ul>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><h3 id="原生测试框架"><a href="#原生测试框架" class="headerlink" title="原生测试框架"></a>原生测试框架</h3><p>仓颉的原生测试框架构建在仓颉的标准库中，为用户提供了先进的测试体验，既允许传统和简单的测试技术，也允许更先进的技术用于更高级的测试场景。测试框架包括三个主要部分：单元测试框架、Mocking测试框架和基准测试框架。</p>
<h4 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h4><p>单元测试框架，顾名思义，允许用户在他们的仓颉项目中创建单元测试。除了能够像实现单个仓颉函数一样创建简单的单元测试之外，它还提供了各种更高级的技术：</p>
<ul>
<li>参数化测试：基于多种输入参数运行被测试代码；</li>
<li>数据驱动测试：从文件中读取多组测试数据，作为入参，运行同一份测试代码；</li>
<li>随机化参数测试：支持结构化构造的不同随机数据作为入参，运行同一份测试代码。相较于业界仅可生成基础类型和字符数组类型的随机值，仓颉提供了更为强大的随机化参数测试能力；</li>
<li>泛型类型参数化测试：对于泛型库开发者，框架可基于同一测试代码，通过传入不同类型参数，测试泛型函数在不同类型上的实现；</li>
<li>死亡测试：对于底层库开发者，框架支持捕获不符合预期的信号，段错误和其他发生在底层库中的错误。</li>
</ul>
<p>此外，为了进一步改善用户体验，测试框架引入了对power assertions和difference assertions的原生实现，提供对测试数据和故障背后原因的详尽说明。</p>
<p>上述这些特性都是灵活可配置的，并可以按需组合使用。例如，测试泛型函数时，使用类型参数化一次生成多种类型实例化实现，传入对应类型下随机生成的测试数据，同时使用 power assertions 和 difference assertions 获取更为清晰的信息。</p>
<h4 id="Mocking框架"><a href="#Mocking框架" class="headerlink" title="Mocking框架"></a>Mocking框架</h4><p>Mocking框架允许用户使用 mock 和 spy 来改变在测试中的仓颉类的行为：这些 mock 或 spy 对象可以通过捕获和修改被处理对象的行为，来测试程序的其余部分如何与该对象交互。Mocking 是一种高级技术，主要用于测试由大量交互组件组成的大型应用程序。</p>
<p>我们的Mocking DSL的设计尽量遵照现有语言mocking框架的风格，让用户的切换过程更加简单。DSL允许指定、验证和修改在测试代码中的对象的行为，并产生可读的错误提示。但与其他Mocking框架不同，仓颉的Mocking框架基于独特的编译器插桩技术实现，用户不仅可以 mock 接口和开发类型，还可以mock final 类。</p>
<p>仓颉的Mocking框架与单元测试框架能够无缝结合，两者的任何功能都可以一起使用，使框架的测试能力更加强大。</p>
<h4 id="基准测试框架"><a href="#基准测试框架" class="headerlink" title="基准测试框架"></a>基准测试框架</h4><p>仓颉测试框架提供了先进的基准测试体验，包括基于线性回归的统计值计算，预热和精确测量。值得一提的是，单元测试框架提供的大多数功能也可用于基准测试，允许参数化测试，参数随机化生成和泛型类型对泛型代码的基准测试。</p>
<p>除此之外，基准测试框架还具有自己的一套功能，例如相对于给定基线的计算，访问原始基准测试数据（以便在需要时进行用户自己的计算）以及分别针对 micro 和 macro 基准测试的精确误差估计。</p>
<h3 id="IDE插件"><a href="#IDE插件" class="headerlink" title="IDE插件"></a>IDE插件</h3><p>仓颉支持在VSCode底座以及Huawei DevEco Studio底座开发，在VSCode底座以及Huawei DevEco Studio底座安装仓颉插件后，实现开箱即用，支持以下特性：</p>
<ul>
<li>工程管理，支持创建、打开仓颉工程（在DevEco Studio支持创建、打开仓颉HarmonyOS工程）；</li>
<li>代码高亮、代码补全、语法诊断、悬浮提示、定义跳转、引用查找、格式化等编码辅助能力，包括元编程相关的编码辅助能力；</li>
<li>编译构建，在HarmonyOS DevEco Studio底座支持推送仓颉HAP包至手机运行能力；</li>
<li>代码调试，包括断点能力、单步调试、调试信息可视化查看能力，在HarmonyOS DevEco Studio底座支持仓颉APP手机调试能力。</li>
</ul>
<h2 id="未来工作规划"><a href="#未来工作规划" class="headerlink" title="未来工作规划"></a>未来工作规划</h2><p>仓颉将始终坚持高效编程、安全可靠、轻松并发、卓越性能的设计理念，给开发者带来友好的编程体验以及高性能的运行体验。同时思考在大模型浪潮下AI for PL、PL for AI的形态。以下介绍一些已经在我们规划中的、令人兴奋的语言能力。</p>
<h3 id="原生智能（AI-Native）应用开发"><a href="#原生智能（AI-Native）应用开发" class="headerlink" title="原生智能（AI Native）应用开发"></a>原生智能（AI Native）应用开发</h3><p>虽然AI技术已被广泛普及和应用，但原生AI应用开发通常需要开发者具备较深的专业知识，并且面临一定的挑战，例如，学习曲线陡峭、集成复杂性等。</p>
<p>常规的AI赋能是通过提供AI应用框架来实现，但是如果能在语言上提供更简洁的语法表达来降低开发者编写原生AI应用的门槛，则能让开发变得更加简单高效。因此仓颉借鉴web端和移动端的技术发展，希望通过DSL能力来构建类似AI领域的声明式范式。</p>
<p>Agent DSL是我们现在正在畅想和尝试的AI原生能力，它是一种专为AI Agent开发和多Agent协同而设计的领域特定语言，是一种内嵌在仓颉语言中的DSL（即eDSL），开发者无需额外学习复杂的库和框架，通过DSL可以简单直观地使用AI功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Agent的定义</span><br><span class="line">@agent class Planner &#123;</span><br><span class="line">  @prompt[pattern=APE] (</span><br><span class="line">    action: &quot;帮助用户制定旅行路线&quot;,</span><br><span class="line">    purpose: &quot;让用户在计划时间内多参观景点并得到充分休息&quot;,</span><br><span class="line">    expectation: “生成一条合理的旅游景点路线，包括时间、景点、通勤等信息&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Agent的使用</span><br><span class="line">let agent = Planner()</span><br><span class="line">let result = agent.chat(&quot;我想前往上海&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码段不难看出，在仓颉语言中对于Agent的声明和使用语法与仓颉本身语法一致，既能享受仓颉的静态检查能力，又不会给开发者带来额外的学习负担，充分发挥仓颉语言的高效编程、安全可靠的优势。</p>
<p>Agent DSL不仅能让我们提升AI应用开发的效率，还能使代码更为准确地对应AI Agent的操作、决策过程。我们整体设计希望能达成如下效果：</p>
<ul>
<li>高级抽象：Agent作为DSL中的内置语言抽象，其定义和描述更加自然直观、易于理解和维护。</li>
<li>极简多Agent协同编程：通过流式符号抽象出不同的 Agent协同模式，开发者可以轻松地利用多 Agent 协作来开发智能化程度更高的应用。</li>
<li>智能化开发工具链：基于Agent DSL，工具链为开发人员提供从应用开发到性能调测、调优的全方位智能支持。</li>
</ul>
<p>除了Agent DSL，原生AI应用框架也是我们正在构建的能力，通过语言原生以及框架的配合给开发者带来全场景智能化时代的应用编程新体验。</p>
<h3 id="DSL-KIT"><a href="#DSL-KIT" class="headerlink" title="DSL KIT"></a>DSL KIT</h3><p>第一阶段我们期望提供易于声明式地指定BNF文法，并自动为DSL生成语法解析器，消除不得不手动编写解析器的复杂性。</p>
<p>第二阶段提供更详细的检查&#x2F;分析&#x2F;优化能力，例如借鉴“属性语法“，将语义附加于声明式语法上，结合编译器提供静态检查能力，在编译期更多的帮助开发者确保DSL上下文的正确性。</p>
<h3 id="Actor和分布式编程"><a href="#Actor和分布式编程" class="headerlink" title="Actor和分布式编程"></a>Actor和分布式编程</h3><p>并发&#x2F;分布式编程在当下多核、众核硬件环境下显得越来越重要，仓颉在语言设计初期就开始考虑这部分的能力支持，并已经初步完成了设计和原型工作，在不久的将来很快就能和开发者见面。</p>
<p>我们希望在仓颉语言中内置Actor特性，并增加类型系统的支持，为开发者提供一种安全且直观的并发&#x2F;分布式模型。</p>
<p>Actor是一种用于并发运算的程序抽象概念，本质是创建一个运算实例，在接收到一则消息时做出响应，如建立新的Actor、发送消息给其他Actor、指定接收到下一个消息要产生的行为等，其通过消息传递的策略在并发线程中进行通信，从而避免数据竞争的问题。</p>
<p>如以下简单示例中，用actor关键字定义Account Actor类型，以及一个实例函数performWithdraw和一个接收器函数withdraw，接收器可以接受和处理消息，实例函数可以访问Actor内部的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">actor Account &#123;</span><br><span class="line">    instance var balance: Int64</span><br><span class="line">    init (x: Int64) &#123; this.balance = f1() &#125;</span><br><span class="line">    instance func performWithdraw(amount: Int64): Unit &#123;</span><br><span class="line">        balance -= amount</span><br><span class="line">    &#125;</span><br><span class="line">    receiver func withdraw(amount: Int64): Bool &#123;</span><br><span class="line">        if (this.balance &lt; amount) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.performWithdraw(amount);</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，仓颉的Actor设计旨在用统一的语言特性来支持并发编程和分步式编程，这可以使开发者采用他们所熟悉编程方式来编写并发或者分布式的程序，然后轻松将其移动到分布式（例如集群）环境中。</p>
<h3 id="IDE-AI赋能"><a href="#IDE-AI赋能" class="headerlink" title="IDE AI赋能"></a>IDE AI赋能</h3><h3 id="可视化并行并发程序调优"><a href="#可视化并行并发程序调优" class="headerlink" title="可视化并行并发程序调优"></a>可视化并行并发程序调优</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cityfire.github.io">CityFire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cityfire.github.io/2024/07/14/cangjie/">https://cityfire.github.io/2024/07/14/cangjie/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cityfire.github.io" target="_blank">CityFire的技术世界</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/06/cangjieInstallForMac/" title="仓颉开发语言MAC版本安装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">仓颉开发语言MAC版本安装</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/04/AtomicService/" title="HarmonyOS元服务"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HarmonyOS元服务</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CityFire</div><div class="author-info__description">软件工程 知其然更要知其所以然</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CityFire"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CityFire" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13787697167@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog(全栈技术杂谈)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">高效编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">多范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">类和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91-what"><span class="toc-number">1.1.2.</span> <span class="toc-text">函数作为一等公民(what?)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">代数数据类型和模式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text">类型扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.3.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%8E%B0%E4%BB%A3%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.4.</span> <span class="toc-text">其他现代特性及语法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">命名参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.4.3.</span> <span class="toc-text">参数默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%9A%8Flambda%EF%BC%88trailing-lambda%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">尾随lambda（trailing lambda）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipeline%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.4.5.</span> <span class="toc-text">管道（Pipeline）操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.6.</span> <span class="toc-text">操作符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%88property%EF%BC%89"><span class="toc-number">1.4.7.</span> <span class="toc-text">属性（property）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0"><span class="toc-number">2.</span> <span class="toc-text">安全可靠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">2.1.</span> <span class="toc-text">静态类型和垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%BC%95%E7%94%A8%E5%AE%89%E5%85%A8"><span class="toc-number">2.2.</span> <span class="toc-text">空引用安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E4%B8%8D%E5%8F%AF%E5%8F%98%E2%80%9D%E4%BC%98%E5%85%88"><span class="toc-number">2.4.</span> <span class="toc-text">“不可变”优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">2.4.1.</span> <span class="toc-text">函数参数不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%B0%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">模式匹配引入的新变量不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%81%E8%AE%B8%E9%80%83%E9%80%B8"><span class="toc-number">2.4.3.</span> <span class="toc-text">闭包捕获可变变量不允许逃逸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%B0%81%E9%97%AD"><span class="toc-number">2.5.</span> <span class="toc-text">默认封闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%8F%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.1.</span> <span class="toc-text">类默认不可继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%8F%AF%E8%A6%86%E7%9B%96"><span class="toc-number">2.5.2.</span> <span class="toc-text">成员方法默认不可覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resources"><span class="toc-number">2.6.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.</span> <span class="toc-text">动态安全检查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.1.</span> <span class="toc-text">溢出检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E6%A3%80%E6%9F%A5"><span class="toc-number">2.7.2.</span> <span class="toc-text">数组越界检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86"><span class="toc-number">2.8.</span> <span class="toc-text">混淆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%AF%92%E5%99%A8"><span class="toc-number">2.9.</span> <span class="toc-text">消毒器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E6%9D%BE%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">轻松并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">轻量化线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">无锁并发对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%93%E8%B6%8A%E6%80%A7%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">卓越性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">静态编译优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">4.2.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B9%B6%E5%8F%91%E6%95%B4%E7%90%86GC"><span class="toc-number">4.3.</span> <span class="toc-text">全并发整理GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E5%8C%96%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-number">4.4.</span> <span class="toc-text">轻量化运行时</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">敏捷扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B"><span class="toc-number">5.1.</span> <span class="toc-text">原生语法扩展能力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.1.</span> <span class="toc-text">类型扩展和属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.1.2.</span> <span class="toc-text">命名参数和参数默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-1"><span class="toc-number">5.1.3.</span> <span class="toc-text">操作符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%9A%8Flambda"><span class="toc-number">5.1.4.</span> <span class="toc-text">尾随lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E7%9C%81%E7%95%A5"><span class="toc-number">5.1.5.</span> <span class="toc-text">关键字省略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">5.2.</span> <span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%AE%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">过程宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Late-stage%E5%AE%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%AE%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">Late-stage宏和模板宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%89%A9%E5%B1%95%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%BC%8FUI"><span class="toc-number">5.3.</span> <span class="toc-text">敏捷扩展案例：声明式UI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">工具支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">包管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">调试器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">6.3.</span> <span class="toc-text">原生测试框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">6.3.1.</span> <span class="toc-text">单元测试框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mocking%E6%A1%86%E6%9E%B6"><span class="toc-number">6.3.2.</span> <span class="toc-text">Mocking框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">6.3.3.</span> <span class="toc-text">基准测试框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE%E6%8F%92%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">IDE插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%92"><span class="toc-number">7.</span> <span class="toc-text">未来工作规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%99%BA%E8%83%BD%EF%BC%88AI-Native%EF%BC%89%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91"><span class="toc-number">7.1.</span> <span class="toc-text">原生智能（AI Native）应用开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DSL-KIT"><span class="toc-number">7.2.</span> <span class="toc-text">DSL KIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Actor%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">Actor和分布式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDE-AI%E8%B5%8B%E8%83%BD"><span class="toc-number">7.4.</span> <span class="toc-text">IDE AI赋能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%B0%83%E4%BC%98"><span class="toc-number">7.5.</span> <span class="toc-text">可视化并行并发程序调优</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/31/Swift_Concurrency/" title="无题">无题</a><time datetime="2025-07-31T14:59:34.262Z" title="发表于 2025-07-31 22:59:34">2025-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/05/CoreBluetooth/" title="Core Bluetooth框架">Core Bluetooth框架</a><time datetime="2025-07-05T13:12:51.133Z" title="发表于 2025-07-05 21:12:51">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/h264video/" title="码流结构：原来你是这样的H264">码流结构：原来你是这样的H264</a><time datetime="2025-06-04T15:01:48.125Z" title="发表于 2025-06-04 23:01:48">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/05/SwiftUI/" title="SwiftUI 的深度思考：从设计哲学到工程实践">SwiftUI 的深度思考：从设计哲学到工程实践</a><time datetime="2025-04-05T13:25:17.329Z" title="发表于 2025-04-05 21:25:17">2025-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/04/architectureForMobileDevelop/" title="iOS 架构的「Spring 化」演进：从组件化到微服务治理">iOS 架构的「Spring 化」演进：从组件化到微服务治理</a><time datetime="2025-04-04T14:05:07.012Z" title="发表于 2025-04-04 22:05:07">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By CityFire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>