<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>设计模式 | CityFire的技术世界</title><meta name="author" content="CityFire"><meta name="copyright" content="CityFire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式概述 模式的诞生与定义  模式(Pattern)起源于建筑业而非软件业 模式之父——美国加利佛尼亚大学环境结构中心研究所所长Christopher Alexander博士 《A Pattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式 模式 Context（模式可适用的前提条件） Theme或Problem（在特定条件">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://cityfire.github.io/2023/11/13/DesignPattern/index.html">
<meta property="og:site_name" content="CityFire的技术世界">
<meta property="og:description" content="设计模式概述 模式的诞生与定义  模式(Pattern)起源于建筑业而非软件业 模式之父——美国加利佛尼亚大学环境结构中心研究所所长Christopher Alexander博士 《A Pattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式 模式 Context（模式可适用的前提条件） Theme或Problem（在特定条件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-11-13T06:24:29.000Z">
<meta property="article:modified_time" content="2023-11-13T06:24:29.000Z">
<meta property="article:author" content="CityFire">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cityfire.github.io/2023/11/13/DesignPattern/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-13 14:24:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="CityFire的技术世界"><span class="site-name">CityFire的技术世界</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-13T06:24:29.000Z" title="发表于 2023-11-13 14:24:29">2023-11-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-13T06:24:29.000Z" title="更新于 2023-11-13 14:24:29">2023-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><ul>
<li><p>模式的诞生与定义</p>
<ul>
<li>模式(<code>Pattern</code>)起源于<code>建筑业</code>而非软件业</li>
<li>模式之父——美国加利佛尼亚大学环境结构中心研究所所长<br><code>Christopher Alexander博士</code></li>
<li><code>《A Pattern Language: Towns, Buildings, Construction》</code>——<code>253</code>个建筑和城市规划模式</li>
<li>模式<ul>
<li><code>Context</code>（模式可适用的前提条件）</li>
<li><code>Theme或Problem</code>（在特定条件下要解决的目标问题）</li>
<li><code>Solution</code>（对目标问题求解过程中各种物理关系的记述）</li>
</ul>
</li>
</ul>
</li>
<li><p>设计模式的定义<br>• 设计模式(<code>Design Pattern</code>)<br>  • 一套<code>被反复使用的</code>、<code>多数人知晓的</code>、<code>经过分类目的</code>、<code>代码设计经验</code>的总结<br>  • 是一种用于对软件系统中不断重现的设计问题的<code>解决方案</code>进行<code>文档化</code>的技术<br>  • 是一种<code>共享专家设计经验</code>的技术<br>  • 目的：<code>为了可重用代码</code>、<code>让代码更容易被他人理解</code>、<code>提高代码可靠性</code></p>
</li>
</ul>
<p>设计模式是<code>在特定环境下</code>为解决<code>某一通用软件设计问题</code>提供的<code>一套定制的解决方案</code>，该方案描述了对象和类之间的相互作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.</span><br></pre></td></tr></table></figure>

<p>设计模式遵循的原则有6个：</p>
<p><strong>开闭原则（Open Close Principle）</strong></p>
<p>对扩展开放，对修改关闭。</p>
<p><strong>1、单一职责原则（Single Responsibility Principle）</strong></p>
<p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>
<p><strong>2、里氏替换原则（Liskov Substitution Principle）</strong></p>
<p>只有当派生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。<a href="https://cityfire.github.io/2023/08/02/inject/">依赖倒置请看这篇文章</a></p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>使用多个隔离的接口来降低耦合度。</p>
<p><strong>5、迪米特法则（最少知道原则）（Demeter Principle）</strong></p>
<p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。</p>
<h2 id="程序设计目标：高内聚，低耦合"><a href="#程序设计目标：高内聚，低耦合" class="headerlink" title="程序设计目标：高内聚，低耦合"></a>程序设计目标：高内聚，低耦合</h2><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>根据目的可以将设计模式分为如下三种类型：</p>
<h3 id="1、创建型-Creational-模式：用于描述“怎样创建对象”。"><a href="#1、创建型-Creational-模式：用于描述“怎样创建对象”。" class="headerlink" title="1、创建型(Creational)模式：用于描述“怎样创建对象”。"></a>1、创建型(Creational)模式：用于描述“怎样创建对象”。</h3><h3 id="2、结构型-Structural-模式：用于描述如何将类或对象按某种布局组成更大的结构。"><a href="#2、结构型-Structural-模式：用于描述如何将类或对象按某种布局组成更大的结构。" class="headerlink" title="2、结构型(Structural)模式：用于描述如何将类或对象按某种布局组成更大的结构。"></a>2、结构型(Structural)模式：用于描述如何将类或对象按某种布局组成更大的结构。</h3><h3 id="3、行为型-Behavioral-模式：用于描述类或对象之间怎样相互协作共同完成某些单个对象都无法单独完成的任务，以及怎样分配职责。"><a href="#3、行为型-Behavioral-模式：用于描述类或对象之间怎样相互协作共同完成某些单个对象都无法单独完成的任务，以及怎样分配职责。" class="headerlink" title="3、行为型(Behavioral)模式：用于描述类或对象之间怎样相互协作共同完成某些单个对象都无法单独完成的任务，以及怎样分配职责。"></a>3、行为型(Behavioral)模式：用于描述类或对象之间怎样相互协作共同完成某些单个对象都无法单独完成的任务，以及怎样分配职责。</h3><p>根据作用范围，即模式主要是处理类之间的关系还是处理对象之间的关系，可以将设计模式分为两类：</p>
<h3 id="1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。"><a href="#1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。" class="headerlink" title="1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。"></a>1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。</h3><h3 id="2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。"><a href="#2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。" class="headerlink" title="2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。"></a>2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。</h3><table>
<thead>
<tr>
<th align="center">范围\目的</th>
<th align="center">创建型模式</th>
<th align="center">结构型模式</th>
<th align="center">行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类模式</td>
<td align="center">工厂方法模式</td>
<td align="center">（类）适配器模式</td>
<td align="center">解释器模式 模板方法模式</td>
</tr>
<tr>
<td align="center">对象模式</td>
<td align="center">抽象工厂模式 建造者模式 原型模式 单例模式</td>
<td align="center">（对象）适配器模式 桥接模式 组合模式 装饰模式 外观模式 享元模式 代理模式</td>
<td align="center">责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 访问者模式</td>
</tr>
</tbody></table>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><strong><code>创建型模式</code>的主要<code>关注点</code>是“<code>怎样创建对象？</code>”，它的<code>主要特点</code>是“<code>将对象的创建与使用分离</code>”。这样可以<code>降低系统的耦合度</code>，使用者不需要<code>关注对象的创建细节</code>。</strong></p>
<h4 id="单例-Singleton-★★★★☆"><a href="#单例-Singleton-★★★★☆" class="headerlink" title="单例(Singleton) ★★★★☆"></a>单例(Singleton) ★★★★☆</h4><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span><br><span class="line">    private static class Holder &#123;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原型-Prototype-★★★☆☆"><a href="#原型-Prototype-★★★☆☆" class="headerlink" title="原型(Prototype) ★★★☆☆"></a>原型(Prototype) ★★★☆☆</h4><p>原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。</p>
<p><code>Object</code> 类中有一个 <code>clone()</code> 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，<code>Java</code> 要求我们的类必须先实现 <code>Cloneable</code> 接口，此接口没有定义任何方法，但是不这么做的话，在 <code>clone()</code> 的时候，会抛出 <code>CloneNotSupportedException</code> 异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p><code>Java</code> 的克隆是<code>浅克隆</code>，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现<code>深克隆</code>的方法是将对象进行<code>序列化</code>，然后再进行<code>反序列化</code>。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
<p>应用场景</p>
<h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;noodle&quot;)) &#123;</span><br><span class="line">            Food noodle = new LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(&quot;more&quot;);</span><br><span class="line">            return noodle;</span><br><span class="line">        &#125; else if (name.equals(&quot;chicken&quot;)) &#123;</span><br><span class="line">            Food chicken = new HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(&quot;potato&quot;);</span><br><span class="line">            return chicken;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>LanZhouNoodle</code> 和 <code>HuangMenChicken</code> 都继承自 <code>Food</code>。</p>
<p>简单地说，简单工厂模式通常就是这样，一个工厂类 <code>XxxFactory</code>，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们强调职责单一原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</span><br></pre></td></tr></table></figure>

<h5 id="工厂方法-Factory-Method-★★★★★"><a href="#工厂方法-Factory-Method-★★★★★" class="headerlink" title="工厂方法(Factory Method) ★★★★★"></a>工厂方法(Factory Method) ★★★★★</h5><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface FoodFactory &#123;</span><br><span class="line">    Food makeFood(String name);</span><br><span class="line">&#125;</span><br><span class="line">public class ChineseFoodFactory implements FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            return new ChineseFoodA();</span><br><span class="line">        &#125; else if (name.equals(&quot;B&quot;)) &#123;</span><br><span class="line">            return new ChineseFoodB();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AmericanFoodFactory implements FoodFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Food makeFood(String name) &#123;</span><br><span class="line">        if (name.equals(&quot;A&quot;)) &#123;</span><br><span class="line">            return new AmericanFoodA();</span><br><span class="line">        &#125; else if (name.equals(&quot;B&quot;)) &#123;</span><br><span class="line">            return new AmericanFoodB();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ChineseFoodA</code>、<code>ChineseFoodB</code>、<code>AmericanFoodA</code>、<code>AmericanFoodB</code> 都派生自 <code>Food</code>。<br>客户端调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class APP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 先选择一个具体的工厂</span><br><span class="line">        FoodFactory factory = new ChineseFoodFactory();</span><br><span class="line">        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span><br><span class="line">        Food food = factory.makeFood(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然都是调用 <code>makeFood(&quot;A&quot;)</code> 制作 <code>A</code> 类食物，但是，不同的工厂生产出来的完全不一样。</p>
<p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p>
<p>核心在于，我们需要在第一步选好我们需要的工厂。比如，我们有 <code>LogFactory</code> 接口，实现类有 <code>FileLogFactory</code> 和 <code>KafkaLogFactory</code>，分别对应将<code>日志</code>写入<code>文件</code>和写入 <code>Kafka</code> 中，显然，我们客户端第一步就需要决定到底要实例化 <code>FileLogFactory</code> 还是 <code>KafkaLogFactory</code>，这将决定之后的所有的操作。</p>
<p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：<br><img src="/images/factoryMethod.png" alt="工厂方法"></p>
<h5 id="抽象工厂-Abstract-Factory-★★★★★"><a href="#抽象工厂-Abstract-Factory-★★★★★" class="headerlink" title="抽象工厂(Abstract Factory) ★★★★★"></a>抽象工厂(Abstract Factory) ★★★★★</h5><p>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</p>
<p>当涉及到产品族的时候，就需要引入抽象工厂模式了。</p>
<p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p>
<p>因为电脑是由许多的构件组成的，我们将 <code>CPU</code> 和主板进行抽象，然后 <code>CPU</code> 由 <code>CPUFactory</code> 生产，主板由 <code>MainBoardFactory</code> 生产，然后，我们再将 <code>CPU</code> 和主板搭配起来组合在一起，如下图：<br><img src="/images/abstractFactory.png" alt="抽象工厂"><br>这个时候的客户端调用是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 得到 Intel 的 CPU</span><br><span class="line">CPUFactory cpuFactory = new IntelCPUFactory();</span><br><span class="line">CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">// 得到 AMD 的主板</span><br><span class="line">MainBoardFactory mainBoardFactory = new AmdMainBoardFactory();</span><br><span class="line">MainBoard mainBoard = mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line">// 组装 CPU 和主板</span><br><span class="line">Computer computer = new Computer(cpu, mainBoard);</span><br></pre></td></tr></table></figure>
<p>单独看 <code>CPU</code> 工厂和主板工厂，它们分别是前面我们说的工厂模式。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 <code>HardDiskFactory</code> 和相应的实现即可，不需要<code>修改现有的工厂</code>。</p>
<p>但是，这种方式有一个问题，那就是如果 <code>Intel</code> 家产的 <code>CPU</code> 和 <code>AMD</code> 产的主板不能兼容使用，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p>
<p>下面就是我们要说的产品族的概念，它代表了组成某个产品的一系列附件的集合：<br><img src="/images/products.png" alt="产品族"></p>
<p>当涉及到这种产品族的问题的时候，就需要<code>抽象工厂模式</code>来支持了。我们不再定义 <code>CPU</code> 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。<br><img src="/images/abstractFactoryPattern.png" alt="抽象工厂模式"></p>
<p>这个时候，对于客户端来说，不再需要单独挑选 <code>CPU</code>厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 第一步就要选定一个“大厂”</span><br><span class="line">    ComputerFactory cf = new AmdFactory();</span><br><span class="line">    // 从这个大厂造 CPU</span><br><span class="line">    CPU cpu = cf.makeCPU();</span><br><span class="line">    // 从这个大厂造主板</span><br><span class="line">    MainBoard board = cf.makeMainBoard();</span><br><span class="line">    // 从这个大厂造硬盘</span><br><span class="line">    HardDisk hardDisk = cf.makeHardDisk();</span><br><span class="line"></span><br><span class="line">    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span><br><span class="line">    Computer result = new Computer(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<code>对修改关闭，对扩展开放</code>这个设计原则。</p>
<h4 id="建造者-Builder-★★☆☆☆"><a href="#建造者-Builder-★★☆☆☆" class="headerlink" title="建造者(Builder) ★★☆☆☆"></a>建造者(Builder) ★★☆☆☆</h4><p>经常碰见的 <code>XxxBuilder</code> 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Food food = new FoodBuilder().a().b().c().build();</span><br><span class="line">Food food = Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure>
<p>套路就是先 <code>new</code> 一个 <code>Builder</code>，然后可以链式地调用一堆方法，最后再调用一次 <code>build()</code> 方法，我们需要的对象就有了。</p>
<p>来一个中规中矩的建造者模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    // 下面是“一堆”的属性</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private String nickName;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    // 构造方法私有化，不然客户端就会直接调用构造方法了</span><br><span class="line">    private User(String name, String password, String nickName, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.nickName = nickName;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span><br><span class="line">    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span><br><span class="line">    public static UserBuilder builder() &#123;</span><br><span class="line">        return new UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class UserBuilder &#123;</span><br><span class="line">        // 下面是和 User 一模一样的一堆属性</span><br><span class="line">        private String  name;</span><br><span class="line">        private String password;</span><br><span class="line">        private String nickName;</span><br><span class="line">        private int age;</span><br><span class="line"></span><br><span class="line">        private UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 链式调用设置各个属性值，返回 this，即 UserBuilder</span><br><span class="line">        public UserBuilder name(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder password(String password) &#123;</span><br><span class="line">            this.password = password;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder nickName(String nickName) &#123;</span><br><span class="line">            this.nickName = nickName;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder age(int age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span><br><span class="line">        // 当然，可以在 “复制” 之前做点检验</span><br><span class="line">        public User build() &#123;</span><br><span class="line">            if (name == null || password == null) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;用户名和密码必填&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (age &lt;= 0 || age &gt;= 150) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;年龄不合法&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 还可以做赋予”默认值“的功能</span><br><span class="line">              if (nickName == null) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            return new User(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心是：先把所有的属性都设置给 <code>Builder</code>，然后 <code>build()</code> 方法的时候，将这些属性复制给实际产生的对象。</p>
<p>看看客户端的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class APP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User d = User.builder()</span><br><span class="line">                .name(&quot;foo&quot;)</span><br><span class="line">                .password(&quot;pAss12345&quot;)</span><br><span class="line">                .age(25)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说实话，建造者模式的链式写法很吸引人，但是，多写了很多“无用”的 <code>builder</code> 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <code>Builder</code> 的构造方法中强制让调用者提供必填字段，还有，在 <code>build()</code> 方法中校验各个参数比在 <code>User</code> 的构造方法中校验，代码要优雅一些。</p>
<p>题外话，强烈建议读者使用 <code>lombok</code>，用了 <code>lombok</code> 以后，上面的一大堆代码会变成如下这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Builder</span><br><span class="line">class User &#123;</span><br><span class="line">    private String  name;</span><br><span class="line">    private String password;</span><br><span class="line">    private String nickName;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">怎么样，省下来的时间是不是又可以干点别的了。</span><br></pre></td></tr></table></figure>
<p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，<code>User</code> 的 <code>getter</code> 方法不变，所有的 <code>setter</code> 方法都让其 <code>return this</code> 就可以了，然后就可以像下面这样调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = new User().setName(&quot;&quot;).setPassword(&quot;&quot;).setAge(20);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</span><br></pre></td></tr></table></figure>


<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h4 id="代理-Proxy-★★★★☆"><a href="#代理-Proxy-★★★★☆" class="headerlink" title="代理(Proxy) ★★★★☆"></a>代理(Proxy) ★★★★☆</h4><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><code>eg</code>: iOS中经常用代理来委托实现功能</p>
<h4 id="适配器-Adapter-★★★★☆"><a href="#适配器-Adapter-★★★★☆" class="headerlink" title="适配器(Adapter) ★★★★☆"></a>适配器(Adapter) ★★★★☆</h4><p>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<p>‘eg’: 比方一个网络API返回不同的类型，有json、xml、pb这三种格式的数据，可以考虑用适配器模式来封装成一致的调用形式来使用。</p>
<h4 id="装饰器-Decorator-★★★☆☆"><a href="#装饰器-Decorator-★★★☆☆" class="headerlink" title="装饰器(Decorator) ★★★☆☆"></a>装饰器(Decorator) ★★★☆☆</h4><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <code>Java IO</code> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p>
<p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：<br><img src="/images/Decorator.png" alt="装饰模式"></p>
<p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要增强这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来装饰实现类，以达到增强的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</span><br></pre></td></tr></table></figure>

<p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <code>ConcreteDecorator***</code> 都可以作为 <code>Component</code> 来使用，因为它们都实现了 <code>Component</code> 中的所有接口。它们和 <code>Component</code> 实现类 <code>ConcreteComponent</code> 的区别是，它们只是装饰者，起装饰作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中加了层皮来装饰而已。</p>
<p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 <code>Java IO</code> 中的装饰模式的应用。</p>
<p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p>
<p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：<code>LemonBlackTea</code>、<code>LemonGreenTea</code>、<code>MangoBlackTea</code>、<code>MangoLemonGreenTea</code>……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p>
<p>不说废话了，上代码。<br>首先，定义饮料抽象基类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Beverage &#123;</span><br><span class="line">      // 返回描述</span><br><span class="line">      public abstract String getDescription();</span><br><span class="line">      // 返回价格</span><br><span class="line">      public abstract double cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后是三个基础饮料实现类，红茶、绿茶和咖啡：</span><br><span class="line">public class BlackTea extends Beverage &#123;</span><br><span class="line">      public String getDescription() &#123;</span><br><span class="line">        return &quot;红茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GreenTea extends Beverage &#123;</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;绿茶&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        return 11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...// 咖啡省略</span><br></pre></td></tr></table></figure>
<p>定义调料，也就是装饰者的基类，此类必须继承自 <code>Beverage</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 调料</span><br><span class="line">public abstract class Condiment extends Beverage &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</span><br><span class="line">public class Lemon extends Condiment &#123;</span><br><span class="line">    private Beverage bevarage;</span><br><span class="line">    // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span><br><span class="line">    // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span><br><span class="line">    public Lemon(Beverage bevarage) &#123;</span><br><span class="line">        this.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        // 装饰</span><br><span class="line">        return bevarage.getDescription() + &quot;, 加柠檬&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        // 装饰</span><br><span class="line">        return beverage.cost() + 2; // 加柠檬需要 2 元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mango extends Condiment &#123;</span><br><span class="line">    private Beverage bevarage;</span><br><span class="line">    public Mango(Beverage bevarage) &#123;</span><br><span class="line">        this.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return bevarage.getDescription() + &quot;, 加芒果&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public double cost() &#123;</span><br><span class="line">        return beverage.cost() + 3; // 加芒果需要 3 元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...// 给每一种调料都加一个类</span><br></pre></td></tr></table></figure>
<p>看客户端调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span><br><span class="line">    Beverage beverage = new GreenTea();</span><br><span class="line">    // 开始装饰</span><br><span class="line">    beverage = new Lemon(beverage); // 先加一份柠檬</span><br><span class="line">    beverage = new Mongo(beverage); // 再加一份芒果</span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + &quot; 价格：￥&quot; + beverage.cost());</span><br><span class="line">    //&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们需要芒果-珍珠-双份柠檬-红茶：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea())))); </span><br></pre></td></tr></table></figure>
<p>是不是很变态？<br>看看下图可能会清晰一些：<br><img src="/images/decoratorPattern.png" alt="装饰模式"><br>到这里，大家应该已经清楚装饰模式了吧。</p>
<p>下面，我们再来说说 <code>Java IO</code> 中的装饰模式。看下图 <code>InputStream</code> 派生出来的部分类：<br><img src="/images/javaDecoratorPattern.png"></p>
<p>我们知道 <code>InputStream</code> 代表了输入流，具体的输入来源可以是文件（<code>FileInputStream</code>）、管道（<code>PipedInputStream</code>）、数组（<code>ByteArrayInputStream</code>）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p>
<p><code>FilterInputStream</code> 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 <code>BufferedInputStream</code> 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，<code>LineNumberInputStream</code> 代表用行号来装饰，在操作的时候就可以取得行号了，<code>DataInputStream</code> 的装饰，使得我们可以从输入流转换为 <code>Java</code> 中的基本类型值。</p>
<p>当然，在 <code>Java IO</code> 中，如果我们使用装饰器的话，就不太适合<code>面向接口编程</code>了，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(&quot;&quot;)));</span><br></pre></td></tr></table></figure>

<p>这样的结果是，<code>InputStream</code> 还是不具有读取行号的功能，因为读取行号的方法定义在 <code>LineNumberInputStream</code> 类中。</p>
<p>我们应该像下面这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream is = new DataInputStream(</span><br><span class="line">                              new BufferedInputStream(</span><br><span class="line">                                  new FileInputStream(&quot;&quot;)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</span><br></pre></td></tr></table></figure>
<h4 id="外观-Facade-★★★★★"><a href="#外观-Facade-★★★★★" class="headerlink" title="外观(Facade) ★★★★★"></a>外观(Facade) ★★★★★</h4><p><code>eg</code>: 以前搞游戏SDK的时候，就是用这个模式来封装API提供给cp调用的。</p>
<h4 id="桥接-Bridge-★★★☆☆"><a href="#桥接-Bridge-★★★☆☆" class="headerlink" title="桥接(Bridge) ★★★☆☆"></a>桥接(Bridge) ★★★☆☆</h4><p>理解桥接模式，其实就是理解代码抽象和解耦。</p>
<p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DrawAPI &#123;</span><br><span class="line">   public void draw(int radius, int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是一系列实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RedPen implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GreenPen implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BluePen implements DrawAPI &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw(int radius, int x, int y) &#123;</span><br><span class="line">        System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个抽象类，此类的实现类都需要使用 <code>DrawAPI</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape &#123;</span><br><span class="line">    protected DrawAPI drawAPI;</span><br><span class="line">    protected Shape(DrawAPI drawAPI) &#123;</span><br><span class="line">        this.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象类的子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 圆形</span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">    private int radius;</span><br><span class="line">    public Circle(int radius, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.draw(radius, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 长方形</span><br><span class="line">public class Rectangle extends Shape &#123;</span><br><span class="line">    private int x;</span><br><span class="line">    private int y;</span><br><span class="line">    public Rectangle(int x, int y, DrawAPI drawAPI) &#123;</span><br><span class="line">        super(drawAPI);</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        drawAPI.draw(0, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来看客户端演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Shape greenCircle = new Circle(10, new GreenPen());</span><br><span class="line">    Shape redRectangle = new Rectangle(4, 8, new RedPen());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p>
<p><img src="/images/brigdePattern.png" alt="桥接模式"></p>
<p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥接模式的优点也是显而易见的，就是非常容易进行扩展。<code>有点C++中的友元类和友元函数那味了</code>。</p>
<h4 id="组合-Composite-★★★★☆"><a href="#组合-Composite-★★★★☆" class="headerlink" title="组合(Composite) ★★★★☆"></a>组合(Composite) ★★★★☆</h4><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><code>eg</code>: <code>文件系统</code>经常使用。以前我们客户端实现<code>直播间</code>里的<code>礼物系统</code>中的<code>礼物面板</code>，就是使用了<code>组合模式</code>来构建不同的<code>礼物组件</code>。</p>
<h4 id="享元-Flyweight-★☆☆☆☆"><a href="#享元-Flyweight-★☆☆☆☆" class="headerlink" title="享元(Flyweight) ★☆☆☆☆"></a>享元(Flyweight) ★☆☆☆☆</h4><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h4 id="策略-Strategy-★★★★☆"><a href="#策略-Strategy-★★★★☆" class="headerlink" title="策略(Strategy) ★★★★☆"></a>策略(Strategy) ★★★★☆</h4><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。（多态的一种表现形式）</p>
<p><code>eg</code>: 经常遇到过<code>if else</code>这种一坨的条件判断逻辑，这个就可以用<code>策略模式</code>来对应不同类型或功能的类来实现。比如登录注册模块验证可以有多种不同的形式，例如<code>手机号码</code>，<code>电子邮箱</code>、<code>QQ/Wechat账号</code>、<code>Apple账号</code>、<code>Fackbook账号</code>、<code>Google账号</code>等，都可以考虑<code>策略模式</code>封装使用。</p>
<h4 id="观察者-Observer-★★★★★"><a href="#观察者-Observer-★★★★★" class="headerlink" title="观察者(Observer) ★★★★★"></a>观察者(Observer) ★★★★★</h4><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<p><code>eg</code>: <code>发布订阅</code>模式，<code>组件间的通信方式</code>也可以考虑采用<code>观察者模式</code>。</p>
<h4 id="模板方法-Template-Method-★★★☆☆"><a href="#模板方法-Template-Method-★★★☆☆" class="headerlink" title="模板方法(Template Method) ★★★☆☆"></a>模板方法(Template Method) ★★★☆☆</h4><h4 id="迭代器-Iterator-★★★★★"><a href="#迭代器-Iterator-★★★★★" class="headerlink" title="迭代器(Iterator) ★★★★★"></a>迭代器(Iterator) ★★★★★</h4><p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</p>
<h4 id="责任链-Chain-of-Responsibility-★★☆☆☆"><a href="#责任链-Chain-of-Responsibility-★★☆☆☆" class="headerlink" title="责任链(Chain of Responsibility) ★★☆☆☆"></a>责任链(Chain of Responsibility) ★★☆☆☆</h4><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p><code>eg</code>: 客户端<code>事件的传递</code>，Java中的<code>过滤器</code>、<code>拦截器</code>等。</p>
<h4 id="命令-Command-★★★★☆"><a href="#命令-Command-★★★★☆" class="headerlink" title="命令(Command) ★★★★☆"></a>命令(Command) ★★★★☆</h4><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>
<p><code>eg</code>: 电视机的<code>遥控器</code>就是典型的<code>命令模式</code>实现。</p>
<h4 id="备忘录-Memento-★★☆☆☆"><a href="#备忘录-Memento-★★☆☆☆" class="headerlink" title="备忘录(Memento) ★★☆☆☆"></a>备忘录(Memento) ★★☆☆☆</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<h4 id="状态-State-★★★☆☆"><a href="#状态-State-★★★☆☆" class="headerlink" title="状态(State) ★★★☆☆"></a>状态(State) ★★★☆☆</h4><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。</p>
<p><code>eg</code>:<code>状态机</code></p>
<h4 id="访问者-Visitor-★☆☆☆☆"><a href="#访问者-Visitor-★☆☆☆☆" class="headerlink" title="访问者(Visitor) ★☆☆☆☆"></a>访问者(Visitor) ★☆☆☆☆</h4><h4 id="中介者-Mediator-★★☆☆☆"><a href="#中介者-Mediator-★★☆☆☆" class="headerlink" title="中介者(Mediator) ★★☆☆☆"></a>中介者(Mediator) ★★☆☆☆</h4><p>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><code>eg</code>:<code>iOS</code>、<code>Android</code>等移动端平台一般用来<code>组件化</code>或<code>插件化</code>，解耦合。</p>
<h4 id="解释器-Interpreter-★☆☆☆☆"><a href="#解释器-Interpreter-★☆☆☆☆" class="headerlink" title="解释器(Interpreter) ★☆☆☆☆"></a>解释器(Interpreter) ★☆☆☆☆</h4><h3 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h3><ul>
<li><code>融合了众多专家的经验</code>，并以一种标准的形式供广大开发人员所用。</li>
<li>提供了一套<code>通用的设计词汇和一种通用的语言</code>，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂。</li>
<li>让人们可以更加简单方便地<code>复用成功的设计和体系结构</code>。</li>
<li>使得设计方案更加<code>灵活</code>，且<code>易于修改</code>。</li>
<li>将提高软件系统的<code>开发效率和软件质量</code>，且在一定程度上节约设计成本。</li>
<li>有助于初学者更深入地<code>理解面向对象思想</code>，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量。</li>
</ul>
<h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML?"></a>什么是UML?</h2><ol>
<li><p><code>UML</code>，全称<code>Unified Modeling Language</code> <code>UML (统一建模语言)</code>， 是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。</p>
</li>
<li><p><code>UML</code> 类似流程图，本身有一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如<code>类、接口、实现、泛化、依赖、组合、聚合</code>等。</p>
</li>
</ol>
<p><code>UML图</code>可以简单分为三类:</p>
<h3 id="用例图-Use-Case-。"><a href="#用例图-Use-Case-。" class="headerlink" title="用例图(Use Case)。"></a>用例图(<code>Use Case</code>)。</h3><h3 id="静态结构图-类图、对象图、包图、组件图、部署图。"><a href="#静态结构图-类图、对象图、包图、组件图、部署图。" class="headerlink" title="静态结构图:类图、对象图、包图、组件图、部署图。"></a>静态结构图:类图、对象图、包图、组件图、部署图。</h3><h3 id="动态行为图-交互图-时序图与协作图-、状态图、活动图。"><a href="#动态行为图-交互图-时序图与协作图-、状态图、活动图。" class="headerlink" title="动态行为图:交互图(时序图与协作图)、状态图、活动图。"></a>动态行为图:交互图(时序图与协作图)、状态图、活动图。</h3><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h3><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>认识<code>UML类图</code>能更好的的学习设计模式，主流的设计模式都能够通过<code>UML类图</code>更加明亮清晰的展示类与类之间的关系；学会<code>UML类图</code>也可以更快速的看懂类与类之间的关系。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cityfire.github.io">CityFire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cityfire.github.io/2023/11/13/DesignPattern/">https://cityfire.github.io/2023/11/13/DesignPattern/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cityfire.github.io" target="_blank">CityFire的技术世界</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/06/Compilers/" title="编译原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">编译原理</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/13/PresentLayerArchitectureDesign/" title="表现层框架设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">表现层框架设计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/13/PresentLayerArchitectureDesign/" title="表现层框架设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">表现层框架设计</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CityFire</div><div class="author-info__description">软件工程 知其然更要知其所以然</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CityFire"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CityFire" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13787697167@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog(全栈技术杂谈)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">设计模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%EF%BC%9A%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%8C%E4%BD%8E%E8%80%A6%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">程序设计目标：高内聚，低耦合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B-Creational-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E2%80%9C%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E2%80%9D%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">1、创建型(Creational)模式：用于描述“怎样创建对象”。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B-Structural-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E5%A6%82%E4%BD%95%E5%B0%86%E7%B1%BB%E6%88%96%E5%AF%B9%E8%B1%A1%E6%8C%89%E6%9F%90%E7%A7%8D%E5%B8%83%E5%B1%80%E7%BB%84%E6%88%90%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">2、结构型(Structural)模式：用于描述如何将类或对象按某种布局组成更大的结构。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B-Behavioral-%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%8F%8F%E8%BF%B0%E7%B1%BB%E6%88%96%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%80%8E%E6%A0%B7%E7%9B%B8%E4%BA%92%E5%8D%8F%E4%BD%9C%E5%85%B1%E5%90%8C%E5%AE%8C%E6%88%90%E6%9F%90%E4%BA%9B%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%97%A0%E6%B3%95%E5%8D%95%E7%8B%AC%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%80%8E%E6%A0%B7%E5%88%86%E9%85%8D%E8%81%8C%E8%B4%A3%E3%80%82"><span class="toc-number">2.4.</span> <span class="toc-text">3、行为型(Behavioral)模式：用于描述类或对象之间怎样相互协作共同完成某些单个对象都无法单独完成的任务，以及怎样分配职责。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%85%B3%E7%B3%BB%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E5%BB%BA%E7%AB%8B%EF%BC%8C%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%8C%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E5%88%BB%E4%BE%BF%E7%A1%AE%E5%AE%9A%E4%B8%8B%E6%9D%A5%E4%BA%86%E3%80%82"><span class="toc-number">2.5.</span> <span class="toc-text">1、类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%85%B3%E7%B3%BB%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%88%96%E8%81%9A%E5%90%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%8C%E6%9B%B4%E5%85%B7%E5%8A%A8%E6%80%81%E6%80%A7%E3%80%82"><span class="toc-number">2.6.</span> <span class="toc-text">2、对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B-Singleton-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">3.0.1.</span> <span class="toc-text">单例(Singleton) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-Prototype-%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86"><span class="toc-number">3.0.2.</span> <span class="toc-text">原型(Prototype) ★★★☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.3.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">简单工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-Factory-Method-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">工厂方法(Factory Method) ★★★★★</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-Abstract-Factory-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">3.0.3.3.</span> <span class="toc-text">抽象工厂(Abstract Factory) ★★★★★</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85-Builder-%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">3.0.4.</span> <span class="toc-text">建造者(Builder) ★★☆☆☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86-Proxy-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">4.0.1.</span> <span class="toc-text">代理(Proxy) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-Adapter-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">4.0.2.</span> <span class="toc-text">适配器(Adapter) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8-Decorator-%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86"><span class="toc-number">4.0.3.</span> <span class="toc-text">装饰器(Decorator) ★★★☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82-Facade-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">4.0.4.</span> <span class="toc-text">外观(Facade) ★★★★★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5-Bridge-%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86"><span class="toc-number">4.0.5.</span> <span class="toc-text">桥接(Bridge) ★★★☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-Composite-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">4.0.6.</span> <span class="toc-text">组合(Composite) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%AB%E5%85%83-Flyweight-%E2%98%85%E2%98%86%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">4.0.7.</span> <span class="toc-text">享元(Flyweight) ★☆☆☆☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-Strategy-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">5.0.1.</span> <span class="toc-text">策略(Strategy) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85-Observer-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">5.0.2.</span> <span class="toc-text">观察者(Observer) ★★★★★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95-Template-Method-%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86"><span class="toc-number">5.0.3.</span> <span class="toc-text">模板方法(Template Method) ★★★☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">5.0.4.</span> <span class="toc-text">迭代器(Iterator) ★★★★★</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE-Chain-of-Responsibility-%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">5.0.5.</span> <span class="toc-text">责任链(Chain of Responsibility) ★★☆☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-Command-%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86"><span class="toc-number">5.0.6.</span> <span class="toc-text">命令(Command) ★★★★☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95-Memento-%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">5.0.7.</span> <span class="toc-text">备忘录(Memento) ★★☆☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-State-%E2%98%85%E2%98%85%E2%98%85%E2%98%86%E2%98%86"><span class="toc-number">5.0.8.</span> <span class="toc-text">状态(State) ★★★☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85-Visitor-%E2%98%85%E2%98%86%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">5.0.9.</span> <span class="toc-text">访问者(Visitor) ★☆☆☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85-Mediator-%E2%98%85%E2%98%85%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">5.0.10.</span> <span class="toc-text">中介者(Mediator) ★★☆☆☆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8-Interpreter-%E2%98%85%E2%98%86%E2%98%86%E2%98%86%E2%98%86"><span class="toc-number">5.0.11.</span> <span class="toc-text">解释器(Interpreter) ★☆☆☆☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">设计模式的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFUML"><span class="toc-number">6.</span> <span class="toc-text">什么是UML?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE-Use-Case-%E3%80%82"><span class="toc-number">6.1.</span> <span class="toc-text">用例图(Use Case)。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%93%E6%9E%84%E5%9B%BE-%E7%B1%BB%E5%9B%BE%E3%80%81%E5%AF%B9%E8%B1%A1%E5%9B%BE%E3%80%81%E5%8C%85%E5%9B%BE%E3%80%81%E7%BB%84%E4%BB%B6%E5%9B%BE%E3%80%81%E9%83%A8%E7%BD%B2%E5%9B%BE%E3%80%82"><span class="toc-number">6.2.</span> <span class="toc-text">静态结构图:类图、对象图、包图、组件图、部署图。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A1%8C%E4%B8%BA%E5%9B%BE-%E4%BA%A4%E4%BA%92%E5%9B%BE-%E6%97%B6%E5%BA%8F%E5%9B%BE%E4%B8%8E%E5%8D%8F%E4%BD%9C%E5%9B%BE-%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%82"><span class="toc-number">6.3.</span> <span class="toc-text">动态行为图:交互图(时序图与协作图)、状态图、活动图。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">6.4.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.5.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96"><span class="toc-number">6.6.</span> <span class="toc-text">泛化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">6.7.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">6.8.</span> <span class="toc-text">聚合</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/31/Swift_Concurrency/" title="无题">无题</a><time datetime="2025-07-31T14:59:34.262Z" title="发表于 2025-07-31 22:59:34">2025-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/05/CoreBluetooth/" title="Core Bluetooth框架">Core Bluetooth框架</a><time datetime="2025-07-05T13:12:51.133Z" title="发表于 2025-07-05 21:12:51">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/h264video/" title="码流结构：原来你是这样的H264">码流结构：原来你是这样的H264</a><time datetime="2025-06-04T15:01:48.125Z" title="发表于 2025-06-04 23:01:48">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/05/SwiftUI/" title="SwiftUI 的深度思考：从设计哲学到工程实践">SwiftUI 的深度思考：从设计哲学到工程实践</a><time datetime="2025-04-05T13:25:17.329Z" title="发表于 2025-04-05 21:25:17">2025-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/04/architectureForMobileDevelop/" title="iOS 架构的「Spring 化」演进：从组件化到微服务治理">iOS 架构的「Spring 化」演进：从组件化到微服务治理</a><time datetime="2025-04-04T14:05:07.012Z" title="发表于 2025-04-04 22:05:07">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By CityFire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>