<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>关于iOS内存的深入排查和优化 | CityFire的技术世界</title><meta name="author" content="CityFire"><meta name="copyright" content="CityFire"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些内存相关的名词 虚拟内存VM虚拟内存机制在这里就不多说了，主要包括内存管理单元MMU、内存映射、分段、分页。在iOS中，一页通常有16KB的内存空间。分配内存的时候，先分配虚拟内存，然后使用的时候再映射到实际的物理内存。一个VM Region指的是一段连续的虚拟内存页，这些页的属性都相同。 123456789101112131415161718192021222324&#x2F;* localized">
<meta property="og:type" content="article">
<meta property="og:title" content="关于iOS内存的深入排查和优化">
<meta property="og:url" content="https://cityfire.github.io/2023/08/02/memoryPerfomance_iOS/index.html">
<meta property="og:site_name" content="CityFire的技术世界">
<meta property="og:description" content="一些内存相关的名词 虚拟内存VM虚拟内存机制在这里就不多说了，主要包括内存管理单元MMU、内存映射、分段、分页。在iOS中，一页通常有16KB的内存空间。分配内存的时候，先分配虚拟内存，然后使用的时候再映射到实际的物理内存。一个VM Region指的是一段连续的虚拟内存页，这些页的属性都相同。 123456789101112131415161718192021222324&#x2F;* localized">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-08-02T09:03:49.000Z">
<meta property="article:modified_time" content="2023-08-02T09:03:49.000Z">
<meta property="article:author" content="CityFire">
<meta property="article:tag" content="Objective-C、Swift、C、C++、Java、Cangjie、ArkTS、Go、Python、Dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cityfire.github.io/2023/08/02/memoryPerfomance_iOS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于iOS内存的深入排查和优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-02 17:03:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="CityFire的技术世界"><span class="site-name">CityFire的技术世界</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于iOS内存的深入排查和优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-02T09:03:49.000Z" title="发表于 2023-08-02 17:03:49">2023-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T09:03:49.000Z" title="更新于 2023-08-02 17:03:49">2023-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="关于iOS内存的深入排查和优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>一些内存相关的名词</p>
<h2 id="虚拟内存VM"><a href="#虚拟内存VM" class="headerlink" title="虚拟内存VM"></a>虚拟内存VM</h2><p>虚拟内存机制在这里就不多说了，主要包括内存管理单元MMU、内存映射、分段、分页。在iOS中，一页通常有16KB的内存空间。<br>分配内存的时候，先分配虚拟内存，然后使用的时候再映射到实际的物理内存。<br>一个<code>VM Region</code>指的是一段连续的虚拟内存页，这些页的属性都相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* localized structure - cannot be safely passed between tasks of differing sizes */</span><br><span class="line">/* Don&#x27;t use this, use MACH_TASK_BASIC_INFO instead */</span><br><span class="line">struct task_basic_info &#123;</span><br><span class="line">    integer_t       suspend_count;  /* suspend count for task */</span><br><span class="line">    vm_size_t       virtual_size;   /* virtual memory size (bytes) */</span><br><span class="line">    vm_size_t       resident_size;  /* resident memory size (bytes) */</span><br><span class="line">    time_value_t    user_time;      /* total user run time for</span><br><span class="line">                                     *  terminated threads */</span><br><span class="line">    time_value_t    system_time;    /* total system run time for</span><br><span class="line">                                     *  terminated threads */</span><br><span class="line">    policy_t        policy;         /* default policy for new threads */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mach_task_basic_info &#123;</span><br><span class="line">    mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">    mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">    mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */</span><br><span class="line">    time_value_t    user_time;          /* total user run time for</span><br><span class="line">                                         *  terminated threads */</span><br><span class="line">    time_value_t    system_time;        /* total system run time for</span><br><span class="line">                                         *  terminated threads */</span><br><span class="line">    policy_t        policy;             /* default policy for new threads */</span><br><span class="line">    integer_t       suspend_count;      /* suspend count for task */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<p>VM分为<code>Clean Memory</code>和<code>Dirty Memory</code>。即:<br>虚拟内存 <code>Virtual Memory = Dirty Memory + Clean Memory + Compressed Memory</code>。<br>复制代码<br>使用<code>malloc</code>函数，申请一段堆内存，则该内存为<code>Clean</code>的。一旦写入数据，通常这块内存会变成<code>Dirty</code>。<br>获取App申请到的所有虚拟内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (int64_t)memoryVirtualSize &#123;</span><br><span class="line">    struct task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t size = (sizeof(task_basic_info_data_t) / sizeof(natural_t));</span><br><span class="line">    kern_return_t ret = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br><span class="line">    if (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.virtual_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<p><code>mach_task_self()</code>表示获取当前的<code>Mach task</code>。</p>
<h2 id="Clean-Memory"><a href="#Clean-Memory" class="headerlink" title="Clean Memory"></a>Clean Memory</h2><p>可以简单理解为能够被写入数据的干净内存。对开发者而言是read-only，而iOS系统可以写入或移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. System Framework、Binary Executable占用的内存</span><br><span class="line">2. 可以被释放（Page Out，iOS上是压缩内存的方式）的文件，包括内存映射文件Memory mapped file（如image、data、model等）。内存映射文件通常是只读的。</span><br><span class="line">3. 系统中可回收、可复用的内存，实际不会立即申请到物理内存，而是真正需要的时候再给。</span><br><span class="line">4. 每个framework都有_DATA_CONST段，当App运行时使用到了某个framework，该framework对应的_DATA_CONST的内存就由clean变为dirty了。</span><br></pre></td></tr></table></figure>
<p>注意：如果通过文件内存映射机制memory mapped file载入内存的，可以先清除这部分内存占用，需要的时候再从文件载入到内存。所以是Clean Memory。</p>
<h2 id="Dirty-Memory"><a href="#Dirty-Memory" class="headerlink" title="Dirty Memory"></a>Dirty Memory</h2><p>主要强调不可被重复使用的内存。对开发者而言，已经写入数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 被写入数据的内存，包括所有heap中的对象、图像解码缓冲(ImageIO, CGRasterData，IOSurface)。</span><br><span class="line">2. 已使用的实际物理内存，系统无法自动回收。</span><br><span class="line">3. heap allocation、caches、decompressed images。</span><br><span class="line">4. 每个framework的_DATA段和_DATA_DIRTY段。</span><br></pre></td></tr></table></figure>
<p>iOS中的内存警告，只会释放clean memory。因为iOS认为dirty memory有数据，不能清理。所以，应尽量避免dirty memory过大。</p>
<p>要清楚地知道Allocations和Dirty Size分别是因为什么？</p>
<p>值得注意的是，在使用 framework 的过程中会产生 Dirty Memory，使用单例或者全局初始化方法是减少 Dirty Memory 不错的方法，因为单例一旦创建就不会销毁，全局初始化方法会在 class 加载时执行。</p>
<p>下方有测量实验，如+50dirty的操作，在release环境不生效，因iOS系统自动做了优化。</p>
<h2 id="Compressed-Memory"><a href="#Compressed-Memory" class="headerlink" title="Compressed Memory"></a>Compressed Memory</h2><p>iOS设备没有swapped memory，而是采用Compressed Memory机制，一般情况下能将目标内存压缩至原有的一半以下。对于缓存数据或可重建数据，尽量使用NSCache或NSPurableData，收到内存警告时，系统自动处理内存释放操作。并且是线程安全的。</p>
<p>这里要注意，压缩内存机制，使得内存警告与释放内存变得稍微复杂一些。即，对于已经被压缩过的内存，如果尝试释放其中一部分，则会先将它解压。而解压过程带来的内存增大，可能得到我们并不期待的结果。如果选用NSDictionary之类的，内存比较紧张时，尝试将NSDictionary的部分内存释放掉。但若NSDictionary之前是压缩状态，释放需要先解压，解压过程可能导致内存增大而适得其反。</p>
<p>所以，我们平常开发所关心的内存占用其实是 Dirty Size和Compressed Size两部分，也应尽量优化这两部分。而Clean Memory一般不用太多关注。</p>
<h2 id="Resident-Memory"><a href="#Resident-Memory" class="headerlink" title="Resident Memory"></a>Resident Memory</h2><p>已经被映射到虚拟内存中的物理内存。而phys_footprint才是真正消耗的物理内存。</p>
<p><code>Resident Memory = Dirty Memory + Clean Memory that loaded in pysical memory</code>。</p>
<p>复制代码</p>
<p>获取App消耗的Resident Memory：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (int64_t)memoryResidentSize &#123;</span><br><span class="line">    struct task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t size = sizeof(task_basic_info_data_t) / sizeof(natural_t);</span><br><span class="line">    kern_return_t ret = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br><span class="line">    if (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return info.resident_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Memory Footprint</span><br><span class="line">/*</span><br><span class="line">* phys_footprint</span><br><span class="line">*   Physical footprint: This is the sum of:</span><br><span class="line">*     + (internal - alternate_accounting)</span><br><span class="line">*     + (internal_compressed - alternate_accounting_compressed)</span><br><span class="line">*     + iokit_mapped</span><br><span class="line">*     + purgeable_nonvolatile</span><br><span class="line">*     + purgeable_nonvolatile_compressed</span><br><span class="line">*     + page_table</span><br><span class="line">*</span><br><span class="line">* internal</span><br><span class="line">*   The task&#x27;s anonymous memory, which on iOS is always resident.</span><br><span class="line">*</span><br><span class="line">* internal_compressed</span><br><span class="line">*   Amount of this task&#x27;s internal memory which is held by the compressor.</span><br><span class="line">*   Such memory is no longer actually resident for the task [i.e., resident in its pmap],</span><br><span class="line">*   and could be either decompressed back into memory, or paged out to storage, depending</span><br><span class="line">*   on our implementation.</span><br><span class="line">*</span><br><span class="line">* iokit_mapped</span><br><span class="line">*   IOKit mappings: The total size of all IOKit mappings in this task, regardless of</span><br><span class="line">    clean/dirty or internal/external state].</span><br><span class="line">*</span><br><span class="line">* alternate_accounting</span><br><span class="line">*   The number of internal dirty pages which are part of IOKit mappings. By definition, these pages</span><br><span class="line">*   are counted in both internal *and* iokit_mapped, so we must subtract them from the total to avoid</span><br><span class="line">*   double counting.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<p>App消耗的实际物理内存，包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Dirty Memory</span><br><span class="line">2. Clean memory but loaded in pysical memory</span><br><span class="line">3. Page Table</span><br><span class="line">4. Compressed Memory</span><br><span class="line">5. IOKit used</span><br><span class="line">6. NSCache， Purgeable等</span><br></pre></td></tr></table></figure>
<p>获取App的Footprint：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (int64_t)memoryPhysFootprint &#123;</span><br><span class="line">    task_vm_info_data_t vmInfo;</span><br><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">    kern_return_t ret = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)&amp;vmInfo, &amp;count);</span><br><span class="line">    if (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return vmInfo.phys_footprint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<p>XNU中Jetsam判断内存过大，使用的也是phys_footprint，而非resident size。<br>获取设备的所有物理内存大小，可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSProcessInfo processInfo].physicalMemory</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<p>内存测量结果</p>
<p>测量环境<br>iPhone 7, iOS 13.3。<br>Clean Memory<br>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	分析	</span><br><span class="line">resident	59	App消耗的内存	</span><br><span class="line">footprint	13	实际物理内存	</span><br><span class="line">VM	4770	App分配的虚拟内存	</span><br><span class="line">Xcode Navigator	14.3	footprint + 调试需要	</span><br></pre></td></tr></table></figure>
<p>加50MB的clean memory</p>
<p>代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__unused char *buf = malloc(50 * 1024 * 1024);</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	60	+1	App消耗的内存</span><br><span class="line">footprint	14	+1	实际物理内存</span><br><span class="line">VM	4817	+47	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	14.3	+0	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>实际，仅增加50MB的VM，而这里额外会有1～2MB的footprint增加，猜测是用于内存映射所需的。</p>
<p>到达虚拟内存上限会报错： error: can’t allocate region，但不会导致崩溃***。<br>同时，申请的过程不会耗时。</p>
<p>再加50MB的clean memory</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	60	+0	App消耗的内存</span><br><span class="line">footprint	14	+0	实际物理内存</span><br><span class="line">VM	4868	+51	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	14.3	+0	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<h2 id="Dirty-Memory-1"><a href="#Dirty-Memory-1" class="headerlink" title="Dirty Memory"></a>Dirty Memory</h2><p>Resident、footprint、VM都增加。是实实在在的内存消耗，各个工具都会统计。<br>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	分析	</span><br><span class="line">resident	59	App消耗的内存	</span><br><span class="line">footprint	13	实际物理内存	</span><br><span class="line">VM	4769	App分配的虚拟内存	</span><br><span class="line">Xcode Navigator	14.3	footprint + 调试需要	</span><br></pre></td></tr></table></figure>
<p>加50MB的dirty memory<br>代码为：<br>&#x2F;&#x2F; 仅此一句，依然是仅申请虚拟内存，物理内存不会变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *buf = malloc(50 * 1024 * 1024 * sizeof(char));</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 内存使用了，所以是实际的物理内存被使用了。即内存有数据了，变成dirty memory。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 50 * 1024 * 1024; i++) &#123;</span><br><span class="line">    buf[i] = (char)rand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	110	+51	App消耗的内存</span><br><span class="line">footprint	64	+51	实际物理内存</span><br><span class="line">VM	4817	+48	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	64.4	+50.1	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>实际增加了50MB的物理内存，Resident Memory也会变化，同时额外多了1～2MB。<br>申请过程比较耗时，超出上限会导致崩溃。<br>但该操作仅在debug下生效，release环境不生效，应该是iOS系统自行的优化。<br>再加50MB的dirty memory</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	160	+50	App消耗的内存</span><br><span class="line">footprint	114	+50	实际物理内存</span><br><span class="line">VM	4868	+51	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	114.4	+50	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p><code>Clean Memory + Dirty Memory</code></p>
<p>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	分析	</span><br><span class="line">resident	59	App消耗的内存	</span><br><span class="line">footprint	13	实际物理内存	</span><br><span class="line">VM	4770	App分配的虚拟内存	</span><br><span class="line">Xcode Navigator	14.3	footprint + 调试需要	</span><br></pre></td></tr></table></figure>
<p>加50MB的clean memory，使用其中10MB</p>
<p>代码为：<br>&#x2F;&#x2F; 申请50MB的虚拟内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *buf = malloc(50 * 1024 * 1024 * sizeof(char));</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 实际只用了10MB，所以10MB的dirty memory</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10 * 1024 * 1024; i++) &#123;</span><br><span class="line">    buf[i] = (char)rand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	70	+11	App消耗的内存</span><br><span class="line">footprint	24	+11	实际物理内存</span><br><span class="line">VM	4817	+47	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	24.3	+10	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>申请了50MB，但实际仅使用了10MB，因此只有这10MB为Dirty Memory。<br>再加50MB的clean memory，使用其中10MB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	80	+10	App消耗的内存</span><br><span class="line">footprint	34	+10	实际物理内存</span><br><span class="line">VM	4868	+51	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	34.3	+10	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><p>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	分析	</span><br><span class="line">resident	59	App消耗的内存	</span><br><span class="line">footprint	13	实际物理内存	</span><br><span class="line">VM	4770	App分配的虚拟内存	</span><br><span class="line">Xcode Navigator	14.3	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>加100MB的VM<br>代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm_address_t address;</span><br><span class="line">vm_size_t size = 100*1024*1024;</span><br><span class="line">// VM Tracker中显示Memory Tag 200</span><br><span class="line">vm_allocate((vm_map_t)mach_task_self(), &amp;address, size, VM_MAKE_TAG(200) | VM_FLAGS_ANYWHERE);</span><br><span class="line">// VM Tracker中显示VM_MEMORY_MALLOC_HUGE</span><br><span class="line">// vm_allocate((vm_map_t)mach_task_self(), &amp;address, size, VM_MAKE_TAG(VM_MEMORY_MALLOC_HUGE) | VM_FLAGS_ANYWHERE);</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	60	+1	App消耗的内存</span><br><span class="line">footprint	14	+1	实际物理内存</span><br><span class="line">VM	4867	+97	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	14.3	+0	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>这里，mach_task_self()表示在自己的进程空间内申请，size的单位是byte。使用参数VM_MAKE_TAG(200)给申请的内存提供一个Tag标记，该数字在VM Tracker中会有标记。<br>再加100MB的VM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	60	+0	App消耗的内存</span><br><span class="line">footprint	14	+0	实际物理内存</span><br><span class="line">VM	4967	+100	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	14.3	+0	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<h4 id="UIImage"><a href="#UIImage" class="headerlink" title="UIImage"></a>UIImage</h4><p>图片大小：map.jpg: 9054*5945<br>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	分析	</span><br><span class="line">resident	60	App消耗的内存	</span><br><span class="line">footprint	14	实际物理内存	</span><br><span class="line">VM	4768	App分配的虚拟内存	</span><br><span class="line">Xcode Navigator	14.3	footprint + 调试需要	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.image = [UIImage imageNamed:@&quot;map.jpg&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	61	+2	App消耗的内存</span><br><span class="line">footprint	14	+0	实际物理内存</span><br><span class="line">VM	4768	+0	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	14.4	+0.1	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>构建UIImage对象所需要的图片数据消耗其实不大。这里的数据指的是压缩的格式化数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.imageView.image = self.image;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型	内存值(MB)	增量	分析</span><br><span class="line">resident	61	+0	App消耗的内存</span><br><span class="line">footprint	92	+78	实际物理内存</span><br><span class="line">VM	4845	+77	App分配的虚拟内存</span><br><span class="line">Xcode Navigator	92	+77.6	footprint + 调试需要</span><br></pre></td></tr></table></figure>
<p>这个阶段，需要将图片数据解码成像素数据bitmap，并渲染到屏幕上。解码过程非常消耗内存和CPU资源，且默认在主线程中执行会阻塞主线程。<br>关于这里的一些详细信息及优化（如异步解码图片数据，主线程渲染），请看后文。<br>结论<br>通过以上的比较，可以对各个内存类型有一个初步直观的认识。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. footprint是App实际消耗的物理内存</span><br><span class="line">2. resident是实际映射到虚拟内存的物理内存</span><br><span class="line">3. 通常看到的Xcode Navigator显示的最接近footprint，另外还有一些调试需要的内存。</span><br></pre></td></tr></table></figure>
<p>几种内存查看方式的区别</p>
<h3 id="Xcode-Navigator"><a href="#Xcode-Navigator" class="headerlink" title="Xcode Navigator"></a>Xcode Navigator</h3><p>初略展示了真实的物理内存消耗。颜色表明了内存占用是否合理。Xcode Navigator &#x3D; footprint + 调试需要。不跟踪VM。往往初略观察App的内存占用情况，不能作为精确的参考。<br>Instuments Allocations<br>这里显示的内存，其实只是整个App占用内存的一部分，即开发者自行分配的内存，如各种类实例等。简单而言，就是开发者自行malloc申请的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 主要是MALLOC_XXX, VM Region, 以及部分App进程创建的VM Region。</span><br><span class="line">2. 非动态的内存，及部分其他动态库创建的VM Region并不在Allocations的统计范围内。</span><br><span class="line">3. 主程序或动态库的_DATA数据段、Stack函数栈，并非通过malloc分配，因此不在Allocations统计内。</span><br></pre></td></tr></table></figure>
<h3 id="All-Heap-Allocations"><a href="#All-Heap-Allocations" class="headerlink" title="All Heap Allocations"></a>All Heap Allocations</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. malloc</span><br><span class="line">2. CFData</span><br><span class="line">3. 其他手动申请的内存，如 *char buf = malloc(50 * 1024 * 1024 * sizeof(char));</span><br></pre></td></tr></table></figure>
<h3 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h3><p>开发者手动分配的内存块，比如一些人脸检测模型等，还有一些C&#x2F;C++代码中的。</p>
<h3 id="All-Anonymous-VM"><a href="#All-Anonymous-VM" class="headerlink" title="All Anonymous VM"></a>All Anonymous VM</h3><p>无法由开发者直接控制，一般由系统接口调用申请的。例如图片之类的大内存，属于All Anonymous VM -&gt; VM: ImageIO_IOSurface_Data，其他的还有IOAccelerator与IOSurface等跟GPU关系比较密切的.</p>
<h3 id="VM-IOAccelerator"><a href="#VM-IOAccelerator" class="headerlink" title="VM: IOAccelerator"></a>VM: IOAccelerator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CVPixelBuffer: An image buffer that holds pixels in main memory.</span><br><span class="line">A Core Video pixel buffer is an image buffer that holds pixels in main memory. Applications generating frames, compressing or decompressing video, or using Core Image can all make use of Core Video pixel buffers.</span><br><span class="line">主要是CVPixelBuffer，通常使用Pool来管理，交给系统自动释放。而释放的时机完全由系统决定，开发者无法控制。</span><br><span class="line">如果不太需要复用的话，可以考虑改为直接使用create函数，不再复用。这样能保证及时释放掉。</span><br></pre></td></tr></table></figure>
<h3 id="VM-IOSurface"><a href="#VM-IOSurface" class="headerlink" title="VM: IOSurface"></a>VM: IOSurface</h3><p>IOSurface是用于存储FBO、RBO等渲染数据的底层数据结构，是跨进程的，通常在CoreGraphics、OpenGLES、Metal之间传递纹理数据。该结构和硬件相关。提供CPU访问VRAM的方式，如创建IOSurface对象后，在CPU往对象里塞纹理数据，GPU就可以直接使用该纹理了。可以简单理解为IOSurface，为CPU和GPU直接搭建了一个传递纹理数据的桥梁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Share hardware-accelerated buffer data (framebuffers and textures) across multiple processes. Manage image memory more efficiently.</span><br><span class="line">The IOSurface framework provides a framebuffer object suitable for sharing across process boundaries. It is commonly used to allow applications to move complex image decompression and draw logic into a separate process to enhance security.</span><br></pre></td></tr></table></figure>
<p>以下内容参考自：iOS 内存管理研究，总结得非常到位了。<br>（CGImage是一个可以惰性初始化(持有原始压缩格式DataBuffer)，并且通过类似引用计数管理真正的Image Bitmap Buffer的设计，<br>只有渲染时通过RetainBytePtr拿到Bitmap Buffer塞给VRAM(IOSurface)，不渲染时ReleaseBytePtr释放Bitmap Buffer，DataBuffer占用本身就小）。<br>通常我们使用UIImageView，系统会自动处理解码过程，在主线程上解码和渲染，会占用CPU，容易引起卡顿。<br>推荐使用ImageIO在后台线程执行图片的解码操作（可参考SDWebImageCoder）。但是ImageIO不支持webp。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASDK的原理：拿空间换时间，换取流畅，牺牲内存，但内存开销比UIKit高。</span><br><span class="line">	正常用一个全屏的UIImageView，直接用image = UIImage(named:xxx)来设置图片，要在主线程解码，但消耗内存反而较小，只有4MB（正常需要10MB）。</span><br><span class="line">	应该是IOSurface对图片数据做了一些优化。但如果是非常大的图片就会阻塞，不建议直接渲染。</span><br><span class="line">	CGImage是一个可以惰性初始化（持有原始压缩格式DataBuffer），并且通过类似ARC管理真正的Image Bitmap Buffer的设计。</span><br><span class="line">	只有渲染时候通过RatainBytePtr拿到Bitmap Buffer塞给VRAM（IOSurface），不渲染时ReleaseBytePtr释放Bitmap Buffer，DataBuffer本身占用很小。</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<h2 id="VM-Stack"><a href="#VM-Stack" class="headerlink" title="VM: Stack"></a>VM: Stack</h2><p>调用堆栈，一般不需要做啥。每个线程都需要500KB左右的栈空间，主线程1MB。</p>
<h2 id="VM-CG-raster-data"><a href="#VM-CG-raster-data" class="headerlink" title="VM: CG raster data"></a>VM: CG raster data</h2><p>SDWebImage的图片解码数据的缓存，为了避免渲染时在主线程解码导致阻塞。如果对于这一点比较介意，可以做相应设置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// Decompressing images that are downloaded and cached can improve peformance but can consume lot of memory.</span><br><span class="line">/// Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption.</span><br><span class="line">[[SDImageCache sharedImageCache] setShouldDecompressImages:NO];</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:NO];</span><br><span class="line">[[SDImageCache sharedImageCache] setShouldCacheImagesInMemory:NO];</span><br></pre></td></tr></table></figure>
<p>复制代码<br>常见堆栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mmap</span><br><span class="line">CGDataProvicerCreateWithCopyOfData</span><br><span class="line">CGBitmapContextCreateImage</span><br><span class="line">[SDWebImageWebPCoder decodedImageWithData:]</span><br><span class="line">[SDWebImageCodersManager decodedImageWithData:]</span><br><span class="line">[SDImageCache diskImageForKey:data:options:]</span><br><span class="line">[SDImageCache queryCacheOperationForKey:options:done:]_block_invoke</span><br></pre></td></tr></table></figure>
<p>复制代码</p>
<h2 id="Instuments-VM-Tracker"><a href="#Instuments-VM-Tracker" class="headerlink" title="Instuments VM Tracker"></a>Instuments VM Tracker</h2><p>interesting VM regions such as graphics- and Core Data-related. Hides mapped files, dylibs, and some large reserved VM regions.<br>比较大块的内存占用，如WebKit、ImageIO、CoreAnimation等VM Region，一般由系统生成和管理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 数据段_DATA，如占用VM为10.6MB，Resident为6261KB，Dirty为1930KB。</span><br><span class="line">2. 数据段_DATA_CONST，每个framework都有，当App在运行时用到了该framework，则此段内存由clean变为dirty。如占用VM为33.9MB，Resident为31.5MB，Dirty为4466KB。</span><br><span class="line">3. 数据段_DATA_DIRTY，每个framework都有_DATA段和_DATA_DIRTY段，内存是dirty的。如占用VM为862KB，Resident为798KB，Dirty为451KB。</span><br><span class="line">4. 有_LINKEDIT，包含了方法和变量的元数据（位置、偏移量），及代码签名等信息。如占用VM为98MB，Resident为22.4MB，Dirty为0KB. 注意：Dirty为0.</span><br><span class="line">5. 代码段_TEXT，如占用VM为252.9MB，Resident为133.7MB，Dirty为80KB。 注意：Dirty几乎为0.</span><br><span class="line">6. mapped file，如占用VM为104.4MB，Resident为7472KB，Dirty为32KB。clean memory。</span><br><span class="line">7. shared memory，如占用VM为64KB，Resident为64KB，Dirty为64KB。</span><br><span class="line">8. unused but dirty shlib __DATA，如占用VM为721KB，Resident为721KB，Dirty为721KB。</span><br></pre></td></tr></table></figure>
<p>其他比如MALLOC_LARGE，MALLOC_NANO等都是申请VM的时候设置的tag。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. MALLOC_LARGE, 如占用VM为384KB，Resident为384KB，Dirty为384KB。</span><br><span class="line">2. MALLOC_NANO, 如占用VM为512MB，Resident为1584KB，Dirty为1568KB。</span><br><span class="line">3. MALLOC_SMALL, 如占用VM为24MB，Resident为896KB，Dirty为800KB。</span><br><span class="line">4. MALLOC_TINY, 如占用VM为4096KB，Resident为432KB，Dirty为432KB。</span><br><span class="line">5. Stack, 如占用VM为2096KB，Resident为144KB，Dirty为128KB。</span><br><span class="line">6. Performance tool data, 调试所需，如占用VM为336KB，Resident为336KB，Dirty为336KB。</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cityfire.github.io">CityFire</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cityfire.github.io/2023/08/02/memoryPerfomance_iOS/">https://cityfire.github.io/2023/08/02/memoryPerfomance_iOS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cityfire.github.io" target="_blank">CityFire的技术世界</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/02/spring_springMVC/" title="spring和springMVC的整合笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring和springMVC的整合笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/02/inject/" title="深入浅出依赖注入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入浅出依赖注入</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CityFire</div><div class="author-info__description">软件工程 知其然更要知其所以然</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CityFire"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CityFire" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:13787697167@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog(全栈技术杂谈)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98VM"><span class="toc-number">1.</span> <span class="toc-text">虚拟内存VM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clean-Memory"><span class="toc-number">2.</span> <span class="toc-text">Clean Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dirty-Memory"><span class="toc-number">3.</span> <span class="toc-text">Dirty Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compressed-Memory"><span class="toc-number">4.</span> <span class="toc-text">Compressed Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resident-Memory"><span class="toc-number">5.</span> <span class="toc-text">Resident Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dirty-Memory-1"><span class="toc-number">6.</span> <span class="toc-text">Dirty Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VM"><span class="toc-number">6.0.1.</span> <span class="toc-text">VM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UIImage"><span class="toc-number">6.0.2.</span> <span class="toc-text">UIImage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-Navigator"><span class="toc-number">6.1.</span> <span class="toc-text">Xcode Navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#All-Heap-Allocations"><span class="toc-number">6.2.</span> <span class="toc-text">All Heap Allocations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Malloc"><span class="toc-number">6.3.</span> <span class="toc-text">Malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#All-Anonymous-VM"><span class="toc-number">6.4.</span> <span class="toc-text">All Anonymous VM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM-IOAccelerator"><span class="toc-number">6.5.</span> <span class="toc-text">VM: IOAccelerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM-IOSurface"><span class="toc-number">6.6.</span> <span class="toc-text">VM: IOSurface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-Stack"><span class="toc-number">7.</span> <span class="toc-text">VM: Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VM-CG-raster-data"><span class="toc-number">8.</span> <span class="toc-text">VM: CG raster data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instuments-VM-Tracker"><span class="toc-number">9.</span> <span class="toc-text">Instuments VM Tracker</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/22/strategyFactoryModern/" title="在SwiftUI中运用策略模式与工厂模式实现灵活登录架构">在SwiftUI中运用策略模式与工厂模式实现灵活登录架构</a><time datetime="2025-08-22T15:25:24.908Z" title="发表于 2025-08-22 23:25:24">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/19/liveActivity/" title="iOS 中使用 ActivityKit 实现 实时活动 通知功能">iOS 中使用 ActivityKit 实现 实时活动 通知功能</a><time datetime="2025-08-19T15:02:11.637Z" title="发表于 2025-08-19 23:02:11">2025-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/31/Swift_Concurrency/" title="Swift Concurrency编程">Swift Concurrency编程</a><time datetime="2025-07-31T14:59:34.262Z" title="发表于 2025-07-31 22:59:34">2025-07-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/05/CoreBluetooth/" title="Core Bluetooth框架">Core Bluetooth框架</a><time datetime="2025-07-05T13:12:51.133Z" title="发表于 2025-07-05 21:12:51">2025-07-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/h264video/" title="码流结构：原来你是这样的H264">码流结构：原来你是这样的H264</a><time datetime="2025-06-04T15:01:48.125Z" title="发表于 2025-06-04 23:01:48">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By CityFire</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>